---
import AdminLayout from "../../../../layouts/AdminLayout.astro";

// Authentication check
const isAuthenticated = Astro.locals.isAuthenticated;
if (!isAuthenticated) {
	return Astro.redirect('/login');
}

const { id } = Astro.params;

const contentRes = await fetch(`${Astro.url.origin}/api/load-content?id=${id}`);
const contentData = await contentRes.json();

if (!contentData.success || !contentData.data) {
	return Astro.redirect("/admin/content");
}

const content = contentData.data;
---

<AdminLayout>
  <h1 class="text-2xl font-bold mb-4 flex items-center gap-2">
    Edit Content: {content.title}
    <span id="edit-db-source-badge" class="badge badge-outline badge-sm">Local DB</span>
  </h1>

  <!-- Info Alert for Database Switching -->
  <div class="alert alert-info mb-4">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
    </svg>
    <div>
      <h3 class="font-bold">Database Switching</h3>
      <div class="text-sm">
        Content will be automatically refreshed when switching databases. 
        If content doesn't exist in the target database, you can save it to create a copy there.
      </div>
    </div>
  </div>

  <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
    <!-- Left Column: Main Form (50% width) -->
    <div class="space-y-6">
      <form id="editForm" class="w-full space-y-6">
        <input type="hidden" name="id" value={content.id} />

        <!-- General Info -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="label">
              <span class="label-text">Title *</span>
            </label>
            <input
              type="text"
              name="title"
              placeholder="Title"
              class="input input-bordered w-full"
              value={content.title}
              required
            />
          </div>

          <div>
            <label class="label">
              <span class="label-text">TMDB ID</span>
            </label>
            <div class="flex gap-2">
              <input
                type="text"
                name="tmdbid"
                placeholder="TMDB ID"
                class="input input-bordered flex-1"
                value={content.tmdbid || ""}
              />
              <button
                id="fetch-tmdb"
                type="button"
                class="btn btn-outline btn-primary">Fetch</button
              >
            </div>
          </div>

          <div>
            <label class="label">
              <span class="label-text">Original Title</span>
            </label>
            <input
              type="text"
              name="orgtitle"
              placeholder="Original Title"
              class="input input-bordered w-full"
              value={content.orgtitle || ""}
            />
          </div>

          <div>
            <label class="label">
              <span class="label-text">Type *</span>
            </label>
            <select name="type" class="select select-bordered w-full" required>
              <option value="movie" selected={content.type === "movie"}
                >Movie</option
              >
              <option value="series" selected={content.type === "series"}
                >Series</option
              >
              <option
                value="y-movie"
                selected={content.type === "y-movie"}>Youth Movie</option
              >
              <option
                value="y-series"
                selected={content.type === "y-series"}
                >Youth Series</option
              >
            </select>
          </div>
        </div>

        <!-- Country -->
        <div>
          <label class="label">
            <span class="label-text">Country (geo) *</span>
          </label>
          <select name="country" class="select select-bordered w-full" required>
            <option value="gb" selected={content.geo === "gb"}
              >United Kingdom</option
            >
            <option value="de" selected={content.geo === "de"}>Germany</option>
            <option value="fr" selected={content.geo === "fr"}>France</option>
            <option value="es" selected={content.geo === "es"}>Spain</option>
            <option value="it" selected={content.geo === "it"}>Italy</option>
            <option value="pt" selected={content.geo === "pt"}>Portugal</option>
            <option value="nl" selected={content.geo === "nl"}
              >Netherlands</option
            >
            <option value="se" selected={content.geo === "se"}>Sweden</option>
            <option value="dk" selected={content.geo === "dk"}>Denmark</option>
            <option value="no" selected={content.geo === "no"}>Norway</option>
            <option value="fi" selected={content.geo === "fi"}>Finland</option>
            <option value="is" selected={content.geo === "is"}>Iceland</option>
            <option value="fo" selected={content.geo === "fo"}
              >Faroe Islands</option
            >
            <option value="pl" selected={content.geo === "pl"}>Poland</option>
            <option value="ru" selected={content.geo === "ru"}>Russia</option>
            <option value="cz" selected={content.geo === "cz"}
              >Czech Republic</option
            >
            <option value="hu" selected={content.geo === "hu"}>Hungary</option>
            <option value="ro" selected={content.geo === "ro"}>Romania</option>
            <option value="bg" selected={content.geo === "bg"}>Bulgaria</option>
            <option value="hr" selected={content.geo === "hr"}>Croatia</option>
            <option value="sk" selected={content.geo === "sk"}>Slovakia</option>
            <option value="si" selected={content.geo === "si"}>Slovenia</option>
            <option value="ee" selected={content.geo === "ee"}>Estonia</option>
            <option value="lv" selected={content.geo === "lv"}>Latvia</option>
            <option value="lt" selected={content.geo === "lt"}>Lithuania</option
            >
            <option value="ua" selected={content.geo === "ua"}>Ukraine</option>
            <option value="by" selected={content.geo === "by"}>Belarus</option>
            <option value="gr" selected={content.geo === "gr"}>Greece</option>
            <option value="mt" selected={content.geo === "mt"}>Malta</option>
            <option value="al" selected={content.geo === "al"}>Albania</option>
            <option value="mk" selected={content.geo === "mk"}
              >North Macedonia</option
            >
            <option value="rs" selected={content.geo === "rs"}>Serbia</option>
            <option value="ba" selected={content.geo === "ba"}
              >Bosnia and Herzegovina</option
            >
            <option value="me" selected={content.geo === "me"}
              >Montenegro</option
            >
            <option value="ie" selected={content.geo === "ie"}>Ireland</option>
            <option value="lu" selected={content.geo === "lu"}
              >Luxembourg</option
            >
            <option value="at" selected={content.geo === "at"}>Austria</option>
            <option value="ch" selected={content.geo === "ch"}
              >Switzerland</option
            >
            <option value="be" selected={content.geo === "be"}>Belgium</option>
            <option value="li" selected={content.geo === "li"}
              >Liechtenstein</option
            >
            <option value="sm" selected={content.geo === "sm"}
              >San Marino</option
            >
            <option value="va" selected={content.geo === "va"}
              >Vatican City</option
            >
            <option value="ad" selected={content.geo === "ad"}>Andorra</option>
            <option value="mc" selected={content.geo === "mc"}>Monaco</option>
          </select>
        </div>

        <!-- Channel Info -->
        <div class="border border-base-300 rounded-lg p-4">
          <h3 class="font-bold text-lg mb-4">Channel Information</h3>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label class="label">
                <span class="label-text">Channel Name *</span>
              </label>
              <input
                type="text"
                name="channel_name"
                placeholder="Channel Name"
                class="input input-bordered w-full"
                value={content.info?.channel?.name || ""}
                required
              />
            </div>

            <div>
              <label class="label">
                <span class="label-text">Channel Country *</span>
              </label>
              <select
                name="channel_country"
                class="select select-bordered w-full"
                required
              >
                <option
                  value="gb"
                  selected={content.info?.channel?.country === "gb"}
                  >United Kingdom</option
                >
                <option
                  value="de"
                  selected={content.info?.channel?.country === "de"}
                  >Germany</option
                >
                <option
                  value="fr"
                  selected={content.info?.channel?.country === "fr"}
                  >France</option
                >
                <option
                  value="es"
                  selected={content.info?.channel?.country === "es"}
                  >Spain</option
                >
                <option
                  value="it"
                  selected={content.info?.channel?.country === "it"}
                  >Italy</option
                >
                <option
                  value="pt"
                  selected={content.info?.channel?.country === "pt"}
                  >Portugal</option
                >
                <option
                  value="nl"
                  selected={content.info?.channel?.country === "nl"}
                  >Netherlands</option
                >
                <option
                  value="se"
                  selected={content.info?.channel?.country === "se"}
                  >Sweden</option
                >
                <option
                  value="dk"
                  selected={content.info?.channel?.country === "dk"}
                  >Denmark</option
                >
                <option
                  value="no"
                  selected={content.info?.channel?.country === "no"}
                  >Norway</option
                >
                <option
                  value="fi"
                  selected={content.info?.channel?.country === "fi"}
                  >Finland</option
                >
                <option
                  value="is"
                  selected={content.info?.channel?.country === "is"}
                  >Iceland</option
                >
                <option
                  value="fo"
                  selected={content.info?.channel?.country === "fo"}
                  >Faroe Islands</option
                >
                <option
                  value="pl"
                  selected={content.info?.channel?.country === "pl"}
                  >Poland</option
                >
                <option
                  value="ru"
                  selected={content.info?.channel?.country === "ru"}
                  >Russia</option
                >
                <option
                  value="cz"
                  selected={content.info?.channel?.country === "cz"}
                  >Czech Republic</option
                >
                <option
                  value="hu"
                  selected={content.info?.channel?.country === "hu"}
                  >Hungary</option
                >
                <option
                  value="ro"
                  selected={content.info?.channel?.country === "ro"}
                  >Romania</option
                >
                <option
                  value="bg"
                  selected={content.info?.channel?.country === "bg"}
                  >Bulgaria</option
                >
                <option
                  value="hr"
                  selected={content.info?.channel?.country === "hr"}
                  >Croatia</option
                >
                <option
                  value="sk"
                  selected={content.info?.channel?.country === "sk"}
                  >Slovakia</option
                >
                <option
                  value="si"
                  selected={content.info?.channel?.country === "si"}
                  >Slovenia</option
                >
                <option
                  value="ee"
                  selected={content.info?.channel?.country === "ee"}
                  >Estonia</option
                >
                <option
                  value="lv"
                  selected={content.info?.channel?.country === "lv"}
                  >Latvia</option
                >
                <option
                  value="lt"
                  selected={content.info?.channel?.country === "lt"}
                  >Lithuania</option
                >
                <option
                  value="ua"
                  selected={content.info?.channel?.country === "ua"}
                  >Ukraine</option
                >
                <option
                  value="by"
                  selected={content.info?.channel?.country === "by"}
                  >Belarus</option
                >
                <option
                  value="gr"
                  selected={content.info?.channel?.country === "gr"}
                  >Greece</option
                >
                <option
                  value="mt"
                  selected={content.info?.channel?.country === "mt"}
                  >Malta</option
                >
                <option
                  value="al"
                  selected={content.info?.channel?.country === "al"}
                  >Albania</option
                >
                <option
                  value="mk"
                  selected={content.info?.channel?.country === "mk"}
                  >North Macedonia</option
                >
                <option
                  value="rs"
                  selected={content.info?.channel?.country === "rs"}
                  >Serbia</option
                >
                <option
                  value="ba"
                  selected={content.info?.channel?.country === "ba"}
                  >Bosnia and Herzegovina</option
                >
                <option
                  value="me"
                  selected={content.info?.channel?.country === "me"}
                  >Montenegro</option
                >
                <option
                  value="ie"
                  selected={content.info?.channel?.country === "ie"}
                  >Ireland</option
                >
                <option
                  value="lu"
                  selected={content.info?.channel?.country === "lu"}
                  >Luxembourg</option
                >
                <option
                  value="at"
                  selected={content.info?.channel?.country === "at"}
                  >Austria</option
                >
                <option
                  value="ch"
                  selected={content.info?.channel?.country === "ch"}
                  >Switzerland</option
                >
                <option
                  value="be"
                  selected={content.info?.channel?.country === "be"}
                  >Belgium</option
                >
                <option
                  value="li"
                  selected={content.info?.channel?.country === "li"}
                  >Liechtenstein</option
                >
                <option
                  value="sm"
                  selected={content.info?.channel?.country === "sm"}
                  >San Marino</option
                >
                <option
                  value="va"
                  selected={content.info?.channel?.country === "va"}
                  >Vatican City</option
                >
                <option
                  value="ad"
                  selected={content.info?.channel?.country === "ad"}
                  >Andorra</option
                >
                <option
                  value="mc"
                  selected={content.info?.channel?.country === "mc"}
                  >Monaco</option
                >
              </select>
            </div>

            <div>
              <label class="label">
                <span class="label-text">Channel Icon</span>
              </label>
              <input
                type="text"
                name="channel_icon"
                placeholder="Channel Icon URL"
                class="input input-bordered w-full"
                value={content.info?.channel?.icon || ""}
              />
            </div>

            <div class="flex items-center">
              <label class="label cursor-pointer">
                <span class="label-text">Channel Info</span>
                <input
                  type="checkbox"
                  name="channel_info"
                  class="checkbox ml-2"
                  checked={content.info?.channel?.info}
                />
              </label>
            </div>
          </div>
        </div>

        <!-- Content Details -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <label class="label">
              <span class="label-text">Duration (minutes) *</span>
            </label>
            <input
              type="number"
              name="duration"
              placeholder="Duration in minutes"
              class="input input-bordered w-full"
              value={content.info?.duration || ""}
              min="0"
              required
            />
          </div>

          <div>
            <label class="label">
              <span class="label-text">Quality *</span>
            </label>
            <select
              name="quality"
              class="select select-bordered w-full"
              required
            >
              <option value="">Select Quality</option>
              <option value="4k" selected={content.quality === "4k"}>4K</option>
              <option value="1080p" selected={content.quality === "1080p"}>1080p</option>
              <option value="720p" selected={content.quality === "720p"}>720p</option>
              <option value="SD" selected={content.quality === "SD"}>SD</option>
            </select>
            <!-- Debug output -->
            <div class="text-xs text-gray-500 mt-1">
              Debug: content.quality = "{content.quality}" | content.info?.quality = "{content.info?.quality}" | Type: {content.type}
            </div>
          </div>

          <div>
            <label class="label">
              <span class="label-text">Online Until *</span>
            </label>
            <input
              type="date"
              name="onlineuntil"
              class="input input-bordered w-full"
              value={content.info?.onlineuntil
                ? content.info.onlineuntil.split("T")[0]
                : ""}
              required
            />
          </div>
        </div>

        <!-- Series Fields -->
        <div id="seriesFields" style="display: none;">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label class="label">
                <span class="label-text">Number of Seasons</span>
              </label>
              <input
                type="number"
                name="seasons"
                placeholder="Number of seasons"
                class="input input-bordered w-full"
                value={content.info?.seasons || ""}
                min="0"
              />
            </div>

            <div>
              <label class="label">
                <span class="label-text">Number of Episodes</span>
              </label>
              <input
                type="number"
                name="episodes"
                placeholder="Total episodes"
                class="input input-bordered w-full"
                value={content.info?.episodes || ""}
                min="0"
              />
            </div>
          </div>
        </div>

        <!-- Language Fields -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <label class="label">
              <span class="label-text">Audio Language(s)</span>
            </label>
            <input
              type="text"
              id="audio_lang_input"
              name="audio_lang"
              placeholder="e.g. de,en"
              class="input input-bordered w-full"
              value={content.info?.spoken_languages
                ? content.info.spoken_languages.join(",")
                : ""}
            />
            <div id="audio_lang_preview" class="mt-2 flex flex-wrap gap-1"></div>
          </div>

          <div>
            <label class="label">
              <span class="label-text">Subtitle Language(s)</span>
            </label>
            <input
              type="text"
              name="subtitle_lang"
              placeholder="e.g. de,en"
              class="input input-bordered w-full"
              value=""
            />
          </div>

          <div>
            <label class="label">
              <span class="label-text">Forced Subtitle Language(s)</span>
            </label>
            <input
              type="text"
              name="forced_subtitle_lang"
              placeholder="e.g. de"
              class="input input-bordered w-full"
              value=""
            />
          </div>
        </div>

        <!-- Description -->
        <div>
          <label class="label">
            <span class="label-text">Description *</span>
          </label>
          <textarea
            name="description"
            class="textarea textarea-bordered h-24 w-full"
            placeholder="Description (HTML allowed)"
            required>{content.info?.description || ""}</textarea
          >
        </div>

        <!-- Media URLs -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="label">
              <span class="label-text">Backdrop URL</span>
            </label>
            <input
              type="url"
              name="backdrop"
              placeholder="Backdrop image URL"
              class="input input-bordered w-full"
              value={content.info?.backdrop || ""}
            />
          </div>

          <div>
            <label class="label">
              <span class="label-text">Poster URL</span>
            </label>
            <input
              type="url"
              name="poster"
              placeholder="Poster image URL"
              class="input input-bordered w-full"
              value={content.info?.poster || ""}
            />
          </div>
        </div>

        <!-- Options -->
        <div class="flex gap-6">
          <label class="label cursor-pointer">
            <input
              type="checkbox"
              name="fskcheck"
              class="checkbox"
              checked={content.fskcheck}
            />
            <span class="label-text ml-2">FSK Check</span>
          </label>

          <label class="label cursor-pointer">
            <input
              type="checkbox"
              name="dyna"
              class="checkbox"
              checked={content.dyna}
            />
            <span class="label-text ml-2">Dyna</span>
          </label>
        </div>

        <!-- Hidden Fields -->
        <input type="hidden" id="spoken_languages" name="spoken_languages" />

        <!-- Submit -->
        <div class="flex gap-4">
          <button type="submit" class="btn btn-primary">Save Changes</button>
          <a href="/admin/content" class="btn btn-ghost">Cancel</a>
        </div>
      </form>
    </div>

    <!-- Right Column: Series Episodes Management (50% width) -->
    <div>
      <!-- Movie Source Fields -->
      <div
        id="movieSourceFields"
        class="border border-base-300 rounded-lg p-4 sticky top-4 mb-4"
      >
        <h3 class="font-bold text-lg mb-4 flex items-center gap-2">
          ðŸŽ¬ <span>Movie Source</span>
        </h3>
        <div class="space-y-4">
          <div>
            <label class="label">
              <span class="label-text">Source URL</span>
            </label>
            <input
              type="text"
              name="movie_src"
              placeholder="Source URL"
              class="input input-bordered w-full"
              value={content.videosource?.src || ""}
            />
          </div>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label class="label">
                <span class="label-text">Source Type</span>
              </label>
              <select name="movie_type" class="select select-bordered w-full">
                <option value="">Select Type</option>
                <option
                  value="mpd"
                  selected={content.videosource?.type ===
                    "application/dash+xml"}>mpd</option
                >
                <option
                  value="m3u8"
                  selected={content.videosource?.type ===
                    "application/x-mpegURL"}>m3u8</option
                >
                <option
                  value="mp4"
                  selected={content.videosource?.type === "video/mp4"}
                  >mp4</option
                >
                <option
                  value="webm"
                  selected={content.videosource?.type === "video/webm"}
                  >webm</option
                >
              </select>
            </div>

            <div>
              <label class="label">
                <span class="label-text">Source Title</span>
              </label>
              <input
                type="text"
                name="movie_title"
                placeholder="Source Title"
                class="input input-bordered w-full"
                value={content.videosource?.title || ""}
              />
            </div>
          </div>
        </div>
      </div>

      <!-- Series Source Fields -->
      <div
        id="seriesSourceFields"
        style="display: none;"
        class="border border-base-300 rounded-lg p-4 sticky top-4"
      >
        <h3 class="font-bold text-lg mb-4 flex items-center gap-2">
          ðŸ“º <span>Series Episodes</span>
        </h3>

        <!-- Episode Form -->
        <div class="space-y-4">
          <div class="bg-base-100 border border-base-300 rounded-lg p-3">
            <h4 class="font-semibold text-sm mb-3 flex items-center gap-2">
              <span id="episode-form-icon">âž•</span>
              <span id="episode-form-title">Add Episode</span>
            </h4>

            <!-- Episode Basic Info -->
            <div class="grid grid-cols-2 gap-2 mb-3">
              <div>
                <label class="label py-1">
                  <span class="label-text text-xs">Type</span>
                </label>
                <select
                  id="playlist_type"
                  class="select select-bordered select-xs"
                >
                  <option value="regular">Regular</option>
                  <option value="ov">OV</option>
                </select>
              </div>
              <div>
                <label class="label py-1">
                  <span class="label-text text-xs">Season *</span>
                </label>
                <input
                  id="playlist_season"
                  type="number"
                  min="1"
                  placeholder="Season"
                  class="input input-bordered input-xs"
                  required
                />
              </div>
            </div>

            <div class="grid grid-cols-2 gap-2 mb-3">
              <div>
                <label class="label py-1">
                  <span class="label-text text-xs">Episode *</span>
                </label>
                <input
                  id="playlist_episode"
                  type="number"
                  min="1"
                  placeholder="Ep"
                  class="input input-bordered input-xs"
                  required
                />
              </div>
              <div>
                <label class="label py-1">
                  <span class="label-text text-xs">Audio *</span>
                </label>
                <input
                  id="playlist_audiolang"
                  type="text"
                  placeholder="de,en"
                  class="input input-bordered input-xs"
                  required
                />
              </div>
            </div>

            <!-- Episode Details -->
            <div class="space-y-2 mb-3">
              <div>
                <label class="label py-1">
                  <span class="label-text text-xs">Title *</span>
                </label>
                <input
                  id="playlist_title"
                  type="text"
                  placeholder="Episode Title"
                  class="input input-bordered input-xs"
                  required
                />
              </div>

              <div>
                <label class="label py-1">
                  <span class="label-text text-xs">Description</span>
                </label>
                <textarea
                  id="playlist_description"
                  placeholder="Description"
                  class="textarea textarea-bordered textarea-xs"
                  rows="2"></textarea>
              </div>
            </div>

            <!-- Source Configuration -->
            <div class="space-y-2 mb-3">
              <div>
                <label class="label py-1">
                  <span class="label-text text-xs">Sources *</span>
                </label>
                <textarea
                  id="playlist_src"
                  placeholder="URLs (one per line)"
                  class="textarea textarea-bordered textarea-xs"
                  rows="2"
                  required></textarea>
              </div>

              <div>
                <label class="label py-1">
                  <span class="label-text text-xs">Type *</span>
                </label>
                <select
                  id="playlist_srctype"
                  class="select select-bordered select-xs"
                >
                  <option value="">Select</option>
                  <option value="mpd">MPD</option>
                  <option value="m3u8">M3U8</option>
                  <option value="mp4">MP4</option>
                  <option value="webm">WebM</option>
                </select>
              </div>
            </div>

            <!-- Form Actions -->
            <div class="flex gap-1">
              <button
                id="add-episode"
                type="button"
                class="btn btn-primary btn-xs flex-1"
              >
                <span id="episode-action-text">Add</span>
              </button>
              <button
                id="cancel-edit-episode"
                type="button"
                class="btn btn-ghost btn-xs"
                style="display: none;"
              >
                Cancel
              </button>
            </div>
          </div>

          <!-- Episode Count and Filter -->
          <div class="flex items-center justify-between mb-2">
            <div class="badge badge-outline badge-sm">
              <span id="episode-count">0</span> episodes
            </div>
            <select
              id="episodes-filter"
              class="select select-bordered select-xs"
            >
              <option value="">All</option>
              <option value="regular">Regular</option>
              <option value="ov">OV</option>
            </select>
          </div>

          <!-- Episodes List -->
          <div id="playlist-list" class="space-y-2 max-h-80 overflow-y-auto">
            <!-- Episodes will be rendered here -->
          </div>

          <!-- Empty State -->
          <div
            id="episodes-empty-state"
            class="text-center py-4 text-base-content/60"
          >
            <div class="text-2xl mb-1">ðŸ“º</div>
            <p class="text-xs">No episodes yet</p>
          </div>

          <!-- Quick Actions -->
          <div class="border-t border-base-300 pt-3 mt-3">
            <div class="flex flex-wrap gap-1">
              <button
                id="clear-all-episodes"
                type="button"
                class="btn btn-error btn-outline btn-xs"
              >
                Clear
              </button>
              <button
                id="sort-episodes"
                type="button"
                class="btn btn-outline btn-xs"
              >
                Sort
              </button>
              <button
                id="export-episodes"
                type="button"
                class="btn btn-outline btn-xs"
              >
                Export
              </button>
              <button
                id="import-episodes"
                type="button"
                class="btn btn-outline btn-xs"
              >
                Import
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script define:vars={{ content }}>
    // Global variables for playlist management
    let playlist = content.playlist || { regular: {}, ov: {} };

    // Map short type to MIME type
    function getMimeType(type) {
      switch (type) {
        case "mpd":
          return "application/dash+xml";
        case "m3u8":
          return "application/x-mpegURL";
        case "mp4":
          return "video/mp4";
        case "webm":
          return "video/webm";
        default:
          return type || "";
      }
    }

    // Map MIME type back to short type
    function getShortType(mimeType) {
      switch (mimeType) {
        case "application/dash+xml":
          return "mpd";
        case "application/x-mpegURL":
          return "m3u8";
        case "video/mp4":
          return "mp4";
        case "video/webm":
          return "webm";
        default:
          return mimeType || "";
      }
    }

    document.addEventListener("DOMContentLoaded", function () {
      // Content ID for API calls
      const contentId = "{id}";

      const typeSelect = document.querySelector('select[name="type"]');
      const seriesFields = document.getElementById("seriesFields");
      const movieSourceFields = document.getElementById("movieSourceFields");
      const seriesSourceFields = document.getElementById("seriesSourceFields");

      // Initialize database source badge
      const editBadge = document.getElementById('edit-db-source-badge');
      if (editBadge && window.adminUtils) {
        const currentSource = window.adminUtils.currentDbSource;
        editBadge.textContent = currentSource === 'cloud' ? 'Cloud DB' : 'Local DB';
        editBadge.className = currentSource === 'cloud' 
          ? 'badge badge-warning badge-sm' 
          : 'badge badge-outline badge-sm';
      }

      // Listen for database source changes
      window.addEventListener('dbSourceChanged', function(event) {
        const newSource = event.detail.source;
        
        // Update the edit form badge
        const editBadge = document.getElementById('edit-db-source-badge');
        if (editBadge) {
          editBadge.textContent = newSource === 'cloud' ? 'Cloud DB' : 'Local DB';
          editBadge.className = newSource === 'cloud' 
            ? 'badge badge-warning badge-sm' 
            : 'badge badge-outline badge-sm';
        }
        
        // Trigger automatic data refresh (handled by the databaseSourceChanged listener)
        document.dispatchEvent(new CustomEvent('databaseSourceChanged', {
          detail: { source: newSource }
        }));
      });

      // Show/hide fields based on type selection
      function updateTypeFields() {
        if (
          !typeSelect ||
          !seriesFields ||
          !movieSourceFields ||
          !seriesSourceFields
        )
          return;

        const val = typeSelect.value;
        const isSeriesType = val === "series" || val === "y-series";
        const isMovieType = val === "movie" || val === "y-movie";

        if (isSeriesType) {
          seriesFields.style.display = "";
          seriesSourceFields.style.display = "";
          movieSourceFields.style.display = "none";
        } else if (isMovieType) {
          seriesFields.style.display = "none";
          seriesSourceFields.style.display = "none";
          movieSourceFields.style.display = "";
        } else {
          // No type selected or other type
          seriesFields.style.display = "none";
          seriesSourceFields.style.display = "none";
          movieSourceFields.style.display = "none";
        }
      }

      if (typeSelect) {
        typeSelect.addEventListener("change", updateTypeFields);
        updateTypeFields();
      }

      // Audio Language Preview Functionality
      const audioLangInput = document.getElementById("audio_lang_input");
      const audioLangPreview = document.getElementById("audio_lang_preview");

      // Function to get country flag class from language code
      function getCountryFlagClass(langCode) {
        const flagMap = {
          de: "de",
          en: "gb",
          fr: "fr",
          es: "es",
          it: "it",
          pt: "pt",
          nl: "nl",
          ru: "ru",
          pl: "pl",
          sv: "se",
          da: "dk",
          no: "no",
          fi: "fi",
          cs: "cz",
          hu: "hu",
          ro: "ro",
          bg: "bg",
          hr: "hr",
          sk: "sk",
          sl: "si",
          et: "ee",
          lv: "lv",
          lt: "lt",
          uk: "ua",
          el: "gr",
          tr: "tr",
        };
        return flagMap[langCode.toLowerCase()] || null;
      }

      // Function to update audio language preview badges
      function updateAudioLangPreview() {
        if (!audioLangInput || !audioLangPreview) return;

        const inputValue = audioLangInput.value.trim();
        audioLangPreview.innerHTML = "";

        if (!inputValue) return;

        const languages = inputValue
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean);

        languages.forEach((lang) => {
          // Remove any backslashes and extract just the language code (e.g., "DE" from "DE-STEREO")
          const cleanLang = lang.replace(/\\/g, '');
          const langCode = cleanLang.split('-')[0];
          
          const flagClass = getCountryFlagClass(langCode);
          
          const badgeContainer = document.createElement("div");
          badgeContainer.className = "flex gap-1 items-center";

          // Flag badge
          if (flagClass) {
            const flagBadge = document.createElement("span");
            flagBadge.className = "badge badge-outline badge-xs";
            flagBadge.innerHTML = `<span class="fi fi-${flagClass}"></span>`;
            badgeContainer.appendChild(flagBadge);
          }

          // Language code badge
          const langBadge = document.createElement("span");
          langBadge.className = "badge badge-outline badge-xs";
          langBadge.textContent = cleanLang.toUpperCase();
          badgeContainer.appendChild(langBadge);

          audioLangPreview.appendChild(badgeContainer);
        });
      }

      // Initialize audio language preview and add event listener
      if (audioLangInput) {
        updateAudioLangPreview(); // Initial render
        audioLangInput.addEventListener("input", updateAudioLangPreview);
      }

      // TMDB fetch functionality
      const fetchTmdbBtn = document.getElementById("fetch-tmdb");
      if (fetchTmdbBtn) {
        fetchTmdbBtn.addEventListener("click", async function () {
          const tmdbIdInput = document.querySelector('input[name="tmdbid"]');
          const typeSelect = document.querySelector('select[name="type"]');

          if (!tmdbIdInput || !typeSelect) {
            alert("Form elements not found");
            return;
          }

          const tmdbId = tmdbIdInput.value.trim();

          if (!tmdbId) {
            alert("Please enter a TMDB ID first");
            return;
          }

          if (!typeSelect.value) {
            alert("Please select a content type first");
            return;
          }

          const mediaType = typeSelect.value.includes("movie") ? "movie" : "tv";

          try {
            this.disabled = true;
            this.textContent = "Fetching...";

            const response = await fetch(
              `https://api.themoviedb.org/3/${mediaType}/${tmdbId}?api_key=${import.meta.env.TMDB_API_KEY}&language=en-US`
            );

            if (!response.ok) {
              throw new Error("TMDB API request failed");
            }

            const data = await response.json();

            // Fill form fields with safety checks
            const titleInput = document.querySelector('input[name="title"]');
            const orgtitleInput = document.querySelector(
              'input[name="orgtitle"]'
            );
            const descriptionInput = document.querySelector(
              'textarea[name="description"]'
            );
            const posterInput = document.querySelector('input[name="poster"]');
            const backdropInput = document.querySelector(
              'input[name="backdrop"]'
            );
            const durationInput = document.querySelector(
              'input[name="duration"]'
            );
            const seasonsInput = document.querySelector(
              'input[name="seasons"]'
            );
            const episodesInput = document.querySelector(
              'input[name="episodes"]'
            );
            const audioLangInput = document.querySelector(
              'input[name="audio_lang"]'
            );
            const spokenLangInput = document.querySelector(
              'input[name="spoken_languages"]'
            );

            if (titleInput) titleInput.value = data.title || data.name || "";
            if (orgtitleInput)
              orgtitleInput.value =
                data.original_title || data.original_name || "";
            if (descriptionInput) descriptionInput.value = data.overview || "";

            if (data.poster_path && posterInput) {
              posterInput.value = `https://image.tmdb.org/t/p/w500${data.poster_path}`;
            }
            if (data.backdrop_path && backdropInput) {
              backdropInput.value = `https://image.tmdb.org/t/p/w1280${data.backdrop_path}`;
            }

            // Handle runtime/duration
            if (data.runtime && durationInput) {
              durationInput.value = data.runtime;
            } else if (
              data.episode_run_time &&
              data.episode_run_time.length > 0 &&
              durationInput
            ) {
              durationInput.value = data.episode_run_time[0];
            }

            // Handle series-specific data
            if (mediaType === "tv") {
              if (data.number_of_seasons && seasonsInput) {
                seasonsInput.value = data.number_of_seasons;
              }
              if (data.number_of_episodes && episodesInput) {
                episodesInput.value = data.number_of_episodes;
              }
            }

            // Handle spoken languages
            if (data.spoken_languages && data.spoken_languages.length > 0) {
              const languages = data.spoken_languages
                .map((lang) => lang.iso_639_1)
                .join(",");
              if (audioLangInput) audioLangInput.value = languages;
              if (spokenLangInput) spokenLangInput.value = languages;
            } else if (data.original_language) {
              if (audioLangInput) audioLangInput.value = data.original_language;
              if (spokenLangInput)
                spokenLangInput.value = data.original_language;
            }

            alert("TMDB data fetched successfully!");
          } catch (error) {
            alert(
              "Failed to fetch TMDB data. Please check the ID and try again."
            );
          } finally {
            this.disabled = false;
            this.textContent = "Fetch";
          }
        });
      }

      // Enhanced Playlist management for series
      const addEpisodeBtn = document.getElementById("add-episode");
      const cancelEditBtn = document.getElementById("cancel-edit-episode");
      const playlistList = document.getElementById("playlist-list");
      const episodeCountBadge = document.getElementById("episode-count");
      const episodesFilter = document.getElementById("episodes-filter");
      const emptyState = document.getElementById("episodes-empty-state");

      // Editing state
      let currentEditingEpisode = null;

      // Update episode count
      function updateEpisodeCount() {
        const regularCount = Object.values(playlist.regular || {}).flat()
          .length;
        const ovCount = Object.values(playlist.ov || {}).flat().length;
        const total = regularCount + ovCount;

        if (episodeCountBadge) {
          const filterType = episodesFilter?.value || "";

          if (filterType === "regular") {
            episodeCountBadge.textContent = `${regularCount}`;
          } else if (filterType === "ov") {
            episodeCountBadge.textContent = `${ovCount}`;
          } else {
            // Show total for "All" filter or no filter
            episodeCountBadge.textContent = `${total}`;
          }
        }

        if (emptyState) {
          const filterType = episodesFilter?.value || "";
          let countToCheck = total;

          if (filterType === "regular") {
            countToCheck = regularCount;
          } else if (filterType === "ov") {
            countToCheck = ovCount;
          }

          emptyState.style.display = countToCheck === 0 ? "block" : "none";
        }
      }

      // Clear episode form
      function clearEpisodeForm() {
        document.getElementById("playlist_type").value = "regular";
        document.getElementById("playlist_season").value = "";
        document.getElementById("playlist_episode").value = "";
        document.getElementById("playlist_title").value = "";
        document.getElementById("playlist_description").value = "";
        document.getElementById("playlist_audiolang").value = "";
        document.getElementById("playlist_src").value = "";
        document.getElementById("playlist_srctype").value = "";

        // Reset form UI
        document.getElementById("episode-form-icon").textContent = "âž•";
        document.getElementById("episode-form-title").textContent =
          "Add New Episode";
        document.getElementById("episode-action-text").textContent =
          "Add Episode";
        addEpisodeBtn.className = "btn btn-primary btn-sm flex-1";
        cancelEditBtn.style.display = "none";

        currentEditingEpisode = null;
      }

      // Set episode form for editing
      function setEpisodeForEdit(type, season, episodeIdx, episodeData) {
        document.getElementById("playlist_type").value = type;
        document.getElementById("playlist_season").value = season;
        document.getElementById("playlist_episode").value = episodeData.episode;
        document.getElementById("playlist_title").value = episodeData.title;
        document.getElementById("playlist_description").value =
          episodeData.description || "";
        document.getElementById("playlist_audiolang").value = Array.isArray(
          episodeData.audiolang
        )
          ? episodeData.audiolang.join(",")
          : episodeData.audiolang;
        document.getElementById("playlist_src").value = episodeData.sources
          .map((s) => s.src)
          .join("\n");
        document.getElementById("playlist_srctype").value = getShortType(
          episodeData.sources[0]?.type || ""
        );

        // Update form UI
        document.getElementById("episode-form-icon").textContent = "âœï¸";
        document.getElementById("episode-form-title").textContent =
          "Edit Episode";
        document.getElementById("episode-action-text").textContent =
          "Update Episode";
        addEpisodeBtn.className = "btn btn-warning btn-sm flex-1";
        cancelEditBtn.style.display = "block";

        currentEditingEpisode = { type, season, episodeIdx };
      }

      // Enhanced render function with edit capabilities
      function renderPlaylistList() {
        if (!playlistList) return;

        const filterType = episodesFilter?.value || "";
        playlistList.innerHTML = "";

        const typesToShow = filterType ? [filterType] : ["regular", "ov"];

        // Calculate totals for dynamic display
        let totalRegular = 0;
        let totalOV = 0;

        typesToShow.forEach((type) => {
          const typeObj = playlist[type] || {};

          if (Object.keys(typeObj).length === 0) return;

          const typeCount = Object.values(typeObj).flat().length;
          if (type === "regular") totalRegular = typeCount;
          if (type === "ov") totalOV = typeCount;

          // Type header with dynamic count
          const typeHeader = document.createElement("div");
          typeHeader.className = "bg-primary/10 rounded-lg p-3 mb-3";
          typeHeader.innerHTML = `
            <div class="flex items-center justify-between">
              <span class="font-bold text-sm uppercase">${type}</span>
              <span class="badge badge-outline badge-xs">${typeCount} episode${typeCount !== 1 ? "s" : ""}</span>
            </div>
          `;
          playlistList.appendChild(typeHeader);

          // Sort seasons
          const sortedSeasons = Object.keys(typeObj).sort(
            (a, b) => Number(a) - Number(b)
          );

          sortedSeasons.forEach((season) => {
            const episodes = typeObj[season];

            episodes.forEach((ep, idx) => {
              const episodeCard = document.createElement("div");
              episodeCard.className =
                "bg-base-100 border border-base-200 rounded-lg p-3 hover:shadow-md transition-shadow";

              // Create audio language badges - properly handle both array and string formats
              let audioLangs = [];
              if (Array.isArray(ep.audiolang)) {
                audioLangs = ep.audiolang;
              } else if (typeof ep.audiolang === "string") {
                audioLangs = ep.audiolang
                  .split(",")
                  .map((s) => s.trim())
                  .filter(Boolean);
              }

              // Function to get country flag class from language code
              function getCountryFlagClass(langCode) {
                const flagMap = {
                  de: "de",
                  en: "gb",
                  fr: "fr",
                  es: "es",
                  it: "it",
                  pt: "pt",
                  nl: "nl",
                  ru: "ru",
                  pl: "pl",
                  sv: "se",
                  da: "dk",
                  no: "no",
                  fi: "fi",
                  cs: "cz",
                  hu: "hu",
                  ro: "ro",
                  bg: "bg",
                  hr: "hr",
                  sk: "sk",
                  sl: "si",
                  et: "ee",
                  lv: "lv",
                  lt: "lt",
                  uk: "ua",
                  el: "gr",
                  tr: "tr",
                };
                return flagMap[langCode.toLowerCase()] || null;
              }

              const audioBadges = audioLangs
                .map((lang) => {
                  // Remove any backslashes and extract just the language code (e.g., "DE" from "DE-STEREO")
                  const cleanLang = lang.replace(/\\/g, '');
                  const langCode = cleanLang.split('-')[0];
                  
                  const flagClass = getCountryFlagClass(langCode.toLowerCase());

                  const flagBadge = flagClass
                    ? `<span class="badge badge-outline badge-xs"><span class="fi fi-${flagClass}"></span></span>`
                    : "";
                  const langBadge = `<span class="badge badge-outline badge-xs">${cleanLang.split('-')[1]}</span>`;
                  return `${flagBadge}${langBadge}`;
                })
                .join(" ");

              episodeCard.innerHTML = `
                <div class="flex items-start justify-between gap-3">
                  <div class="flex-1 min-w-0">
                    <div class="flex items-center gap-1 mb-1 flex-wrap">
                      <span class="badge badge-primary badge-xs">S${season}E${ep.episode}</span>
                      ${audioBadges}
                    </div>
                    <h5 class="font-medium text-sm truncate">${ep.title}</h5>
                    ${ep.description ? `<p class="text-xs text-base-content/60 mt-1 line-clamp-2">${ep.description}</p>` : ""}
                    <div class="text-xs text-base-content/50 mt-2">
                      ${ep.sources.length} source${ep.sources.length !== 1 ? "s" : ""} â€¢ ${getShortType(ep.sources[0]?.type || "").toUpperCase()}
                    </div>
                  </div>
                  <div class="flex flex-col gap-1">
                    <button class="btn btn-ghost btn-xs" onclick="editEpisode('${type}', '${season}', ${idx})">
                      âœï¸
                    </button>
                    <button class="btn btn-ghost btn-xs text-error" onclick="deleteEpisode('${type}', '${season}', ${idx})">
                      ðŸ—‘ï¸
                    </button>
                  </div>
                </div>
              `;

              playlistList.appendChild(episodeCard);
            });
          });
        });

        updateEpisodeCount();
      }

      // Global functions for episode management
      window.editEpisode = function (type, season, episodeIdx) {
        const episodeData = playlist[type][season][episodeIdx];
        setEpisodeForEdit(type, season, episodeIdx, episodeData);
      };

      window.deleteEpisode = function (type, season, episodeIdx) {
        const episodeData = playlist[type][season][episodeIdx];
        if (
          confirm(
            `Delete "${episodeData.title}" (S${season}E${episodeData.episode})?`
          )
        ) {
          playlist[type][season].splice(episodeIdx, 1);
          if (playlist[type][season].length === 0) {
            delete playlist[type][season];
          }
          renderPlaylistList();

          // Clear form if we were editing this episode
          if (
            currentEditingEpisode &&
            currentEditingEpisode.type === type &&
            currentEditingEpisode.season === season &&
            currentEditingEpisode.episodeIdx === episodeIdx
          ) {
            clearEpisodeForm();
          }
        }
      };

      // Episode form submission
      if (addEpisodeBtn) {
        addEpisodeBtn.addEventListener("click", function () {
          const type = document.getElementById("playlist_type").value;
          const season = document
            .getElementById("playlist_season")
            .value.trim();
          const episode = document
            .getElementById("playlist_episode")
            .value.trim();
          const title = document.getElementById("playlist_title").value.trim();
          const description = document
            .getElementById("playlist_description")
            .value.trim();
          const audiolang = document
            .getElementById("playlist_audiolang")
            .value.trim();
          const srcRaw = document.getElementById("playlist_src").value;
          const srctype = document.getElementById("playlist_srctype").value;

          const srcList = srcRaw
            .split("\n")
            .map((s) => s.trim())
            .filter(Boolean);

          // Validation
          if (
            !season ||
            !episode ||
            !title ||
            !audiolang ||
            srcList.length === 0 ||
            !srctype
          ) {
            alert(
              "Please fill in all required fields (Season, Episode, Title, Audio Languages, Sources, and Source Type)"
            );
            return;
          }

          const audiolangVal =
            type === "ov"
              ? audiolang
              : audiolang
                  .split(",")
                  .map((s) => s.trim())
                  .filter(Boolean);
          const sourcesArr = srcList.map((src) => ({
            src,
            type: getMimeType(srctype),
          }));

          const epObj = {
            season: Number(season),
            episode: Number(episode),
            title,
            description: description || undefined,
            audiolang: audiolangVal,
            sources: sourcesArr,
          };

          if (currentEditingEpisode) {
            // Update existing episode
            const {
              type: editType,
              season: editSeason,
              episodeIdx,
            } = currentEditingEpisode;
            playlist[editType][editSeason][episodeIdx] = epObj;
          } else {
            // Add new episode
            if (!playlist[type]) playlist[type] = {};
            if (!playlist[type][season]) playlist[type][season] = [];

            // Check for duplicate episode
            const duplicate = playlist[type][season].find(
              (ep) => ep.episode === Number(episode)
            );
            if (duplicate) {
              if (
                !confirm(
                  `Episode ${episode} already exists in Season ${season}. Replace it?`
                )
              ) {
                return;
              }
              const idx = playlist[type][season].findIndex(
                (ep) => ep.episode === Number(episode)
              );
              playlist[type][season][idx] = epObj;
            } else {
              playlist[type][season].push(epObj);
            }
          }

          renderPlaylistList();
          clearEpisodeForm();
        });
      }

      // Cancel edit
      if (cancelEditBtn) {
        cancelEditBtn.addEventListener("click", clearEpisodeForm);
      }

      // Episodes filter
      if (episodesFilter) {
        episodesFilter.addEventListener("change", renderPlaylistList);
      }

      // Quick actions
      const clearAllBtn = document.getElementById("clear-all-episodes");
      const sortEpisodesBtn = document.getElementById("sort-episodes");
      const exportBtn = document.getElementById("export-episodes");
      const importBtn = document.getElementById("import-episodes");

      if (clearAllBtn) {
        clearAllBtn.addEventListener("click", function () {
          if (
            confirm(
              "Are you sure you want to clear all episodes? This cannot be undone."
            )
          ) {
            playlist = { regular: {}, ov: {} };
            renderPlaylistList();
            clearEpisodeForm();
          }
        });
      }

      if (sortEpisodesBtn) {
        sortEpisodesBtn.addEventListener("click", function () {
          // Sort episodes within each season
          ["regular", "ov"].forEach((type) => {
            if (playlist[type]) {
              Object.keys(playlist[type]).forEach((season) => {
                playlist[type][season].sort((a, b) => a.episode - b.episode);
              });
            }
          });
          renderPlaylistList();
        });
      }

      if (exportBtn) {
        exportBtn.addEventListener("click", function () {
          const dataStr = JSON.stringify(playlist, null, 2);
          const dataBlob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(dataBlob);
          const link = document.createElement("a");
          link.href = url;
          link.download = "episodes.json";
          link.click();
          URL.revokeObjectURL(url);
        });
      }

      if (importBtn) {
        importBtn.addEventListener("click", function () {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".json";
          input.onchange = function (e) {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = function (e) {
                try {
                  const importedData = JSON.parse(e.target.result);
                  if (
                    confirm("This will replace all current episodes. Continue?")
                  ) {
                    playlist = importedData;
                    renderPlaylistList();
                    clearEpisodeForm();
                  }
                } catch (error) {
                  alert("Invalid JSON file");
                }
              };
              reader.readAsText(file);
            }
          };
          input.click();
        });
      }

      // Form submission
      const editForm = document.getElementById("editForm");
      if (editForm) {
        editForm.addEventListener("submit", async function (event) {
          event.preventDefault();

          const formData = new FormData(this);
          const formObject = Object.fromEntries(formData.entries());

          // Transform the form data to match the API expected format
          const apiData = {
            id: formObject.id,
            data: {
              title: formObject.title,
              orgtitle: formObject.orgtitle || null,
              geo: formObject.country || "de",
              fskcheck: formObject.fskcheck === "on",
              dyna: formObject.dyna === "on",
              info: {
                type: formObject.type,
                description: formObject.description,
                quality: formObject.quality || "",
                duration: formObject.duration
                  ? parseInt(formObject.duration)
                  : 0,
                seasons: formObject.seasons ? parseInt(formObject.seasons) : 0,
                episodes: formObject.episodes
                  ? parseInt(formObject.episodes)
                  : 0,
                onlineuntil: formObject.onlineuntil
                  ? formObject.onlineuntil + "T23:59:59Z"
                  : "",
                poster: formObject.poster || null,
                backdrop: formObject.backdrop || null,
                channel: {
                  name: formObject.channel_name,
                  country:
                    formObject.channel_country || formObject.country || "de",
                  icon: formObject.channel_icon || null,
                  info: formObject.channel_info === "on",
                },
                cast: content.info?.cast || null,
                crew: content.info?.crew || null,
                spoken_languages: formObject.audio_lang
                  ? formObject.audio_lang
                      .split(",")
                      .map((s) => s.trim())
                      .filter(Boolean)
                  : undefined,
              },
              // Add movie source if movie
              videosource:
                formObject.type === "movie" || formObject.type === "y-movie"
                  ? {
                      src: formObject.movie_src || "",
                      type: getMimeType(formObject.movie_type || ""),
                      title: formObject.movie_title || "",
                      poster: "",
                      audiolang: [],
                      sources: [],
                    }
                  : undefined,
              // Add playlist if series
              playlist:
                formObject.type === "series" || formObject.type === "y-series"
                  ? playlist
                  : undefined,
            },
            source: window.adminUtils?.currentDbSource || "local",
          };

          try {
            const response = await fetch("/api/save-content", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(apiData),
            });

            const result = await response.json();

            if (response.ok && result.success) {
              const currentSource = window.adminUtils?.currentDbSource || "local";
              const message = currentSource === 'cloud' 
                ? "Content saved to cloud database successfully!" 
                : "Content saved to local database successfully!";
              alert(message);
              window.location.href = "/admin/content";
            } else {
              alert(
                "Failed to update content: " + (result.error || "Unknown error")
              );
            }
          } catch (error) {
            alert("Failed to update content due to network error.");
          }
        });
      }

      // Initial playlist render
      renderPlaylistList();
      
      // Listen for database source changes and auto-refresh data
      document.addEventListener('databaseSourceChanged', async function(e) {
        const newSource = e.detail.source;
        
        try {
          // Show loading state
          const form = document.getElementById('editForm');
          if (form) {
            form.style.opacity = '0.5';
            form.style.pointerEvents = 'none';
          }
          
          // Load content from new database source
          const response = await fetch(`/api/load-content?id=${contentId}&source=${newSource}`);
          const result = await response.json();
        if (result.success && result.data) {
          // Update form fields with new data
          populateFormWithData(result.data);
          
          // Show success message
          const toast = document.createElement('div');
          toast.className = 'toast toast-top toast-end';
          toast.innerHTML = `<div class="alert alert-success"><span>Data refreshed from ${newSource} database</span></div>`;
          document.body.appendChild(toast);
          setTimeout(() => toast.remove(), 3000);
        } else {
          
          // Check if it's a "Content not found" error
          if (result.error && result.error.includes('Content not found')) {
            const toast = document.createElement('div');
            toast.className = 'toast toast-top toast-end';
            toast.innerHTML = `<div class="alert alert-warning">
              <span>âš ï¸ This content doesn't exist in the ${newSource} database. You can save it to create a copy there.</span>
            </div>`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 5000);
            
            // Clear form but keep the basic structure
            clearFormForNewContent();
          } else {
            alert('Failed to load content from ' + newSource + ' database: ' + (result.error || 'Unknown error'));
          }
        }
        } catch (error) {
          alert('Error refreshing content: ' + error.message);
        } finally {
          // Remove loading state
          const form = document.getElementById('editForm');
          if (form) {
            form.style.opacity = '1';
            form.style.pointerEvents = 'auto';
          }
        }
      });
      
      // Function to populate form fields with loaded data
      function populateFormWithData(data) {
        // Update global content data
        content = data;
        
        // Basic fields
        const titleField = document.querySelector('input[name="title"]');
        if (titleField) titleField.value = data.title || '';
        
        const orgtitleField = document.querySelector('input[name="orgtitle"]');
        if (orgtitleField) orgtitleField.value = data.orgtitle || '';
        
        const typeField = document.querySelector('select[name="type"]');
        if (typeField) typeField.value = data.info.type || '';
        
        const qualityField = document.querySelector('select[name="quality"]');
        if (qualityField) qualityField.value = data.info.quality || '';
        
        const durationField = document.querySelector('input[name="duration"]');
        if (durationField) durationField.value = data.info.duration || '';
        
        const seasonsField = document.querySelector('input[name="seasons"]');
        if (seasonsField) seasonsField.value = data.info.seasons || '';
        
        const episodesField = document.querySelector('input[name="episodes"]');
        if (episodesField) episodesField.value = data.info.episodes || '';
        
        const descriptionField = document.querySelector('textarea[name="description"]');
        if (descriptionField) descriptionField.value = data.info.description || '';
        
        const backdropField = document.querySelector('input[name="backdrop"]');
        if (backdropField) backdropField.value = data.info.backdrop || '';
        
        const posterField = document.querySelector('input[name="poster"]');
        if (posterField) posterField.value = data.info.poster || '';
        
        const fskcheckField = document.querySelector('input[name="fskcheck"]');
        if (fskcheckField) fskcheckField.checked = data.fskcheck || false;
        
        const dynaField = document.querySelector('input[name="dyna"]');
        if (dynaField) dynaField.checked = data.dyna || false;
        
        // Date fields
        const onlineuntilField = document.querySelector('input[name="onlineuntil"]');
        if (onlineuntilField && data.info.onlineuntil) {
          const date = new Date(data.info.onlineuntil);
          onlineuntilField.value = date.toISOString().split('T')[0];
        } else if (onlineuntilField) {
          onlineuntilField.value = '';
        }
        
        // Channel fields
        const channelNameField = document.querySelector('input[name="channel_name"]');
        if (channelNameField) channelNameField.value = data.info.channel?.name || '';
        
        const channelCountryField = document.querySelector('select[name="channel_country"]');
        if (channelCountryField) channelCountryField.value = data.info.channel?.country || 'de';
        
        const channelIconField = document.querySelector('input[name="channel_icon"]');
        if (channelIconField) channelIconField.value = data.info.channel?.icon || '';
        
        const channelInfoField = document.querySelector('input[name="channel_info"]');
        if (channelInfoField) channelInfoField.checked = data.info.channel?.info || false;
        
        // Cast and crew arrays
        const castField = document.querySelector('textarea[name="cast"]');
        if (castField) castField.value = data.info.cast ? JSON.stringify(data.info.cast, null, 2) : '';
        
        const crewField = document.querySelector('textarea[name="crew"]');
        if (crewField) crewField.value = data.info.crew ? JSON.stringify(data.info.crew, null, 2) : '';
        
        // Update episodes display for series
        if (data.info.type === 'series' || data.info.type === 'yseries') {
          playlist = data.playlist || {};
          renderPlaylistList();
        } else {
          // Clear episodes for movies
          playlist = {};
          renderPlaylistList();
        }
      }
      
      // Function to clear form when content doesn't exist in target database
      function clearFormForNewContent() {
        // Keep the title and basic info but clear database-specific fields
        const formFields = [
          'input[name="orgtitle"]',
          'textarea[name="description"]',
          'input[name="backdrop"]',
          'input[name="poster"]',
          'input[name="duration"]',
          'input[name="seasons"]',
          'input[name="episodes"]',
          'input[name="onlineuntil"]',
          'input[name="channel_name"]',
          'input[name="channel_icon"]',
          'textarea[name="cast"]',
          'textarea[name="crew"]'
        ];
        
        formFields.forEach(selector => {
          const field = document.querySelector(selector);
          if (field) field.value = '';
        });
        
        // Reset checkboxes
        const checkboxes = ['input[name="fskcheck"]', 'input[name="dyna"]', 'input[name="channel_info"]'];
        checkboxes.forEach(selector => {
          const field = document.querySelector(selector);
          if (field) field.checked = false;
        });
        
        // Reset dropdowns to default
        const qualityField = document.querySelector('select[name="quality"]');
        if (qualityField) qualityField.value = '';
        
        const channelCountryField = document.querySelector('select[name="channel_country"]');
        if (channelCountryField) channelCountryField.value = 'de';
        
        // Clear episodes
        playlist = {};
        renderPlaylistList();
      }
    });
  </script>
</AdminLayout>
