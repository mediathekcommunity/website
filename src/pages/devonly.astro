---
import Layout from "../layouts/default.astro";

// Only render this page in development mode
if (import.meta.env.PROD) {
  throw new Error("Not found");
}
// Map short type to MIME type
function getMimeType(type: any) {
  switch (type) {
    case "mpd":
      return "application/dash+xml";
    case "m3u8":
      return "application/x-mpegURL";
    case "mp4":
      return "video/mp4";
    case "webm":
      return "video/webm";
    default:
      return type || "";
  }
}
---

<Layout>
  <div class="flex flex-col items-center justify-center min-h-screen">
    <h1 class="text-3xl font-bold mb-8">Dev Form (daisyUI 5)</h1>
    <div
      class="flex flex-col md:flex-row gap-8 w-full justify-center items-stretch"
    >
      <div class="flex flex-row gap-8 w-full justify-center items-stretch">
        <!-- 5-column layout: 1. File list, 2. TMDB debug, 3. Form, 4. Normal debug, 5. Episode JSON debug -->

        <!-- File List Column -->
        <div class="flex flex-col w-full max-w-xs" style="max-width: 18rem;">
          <div
            id="file-list-card"
            class="bg-base-200 p-4 rounded-lg shadow-lg flex flex-col gap-2 border-2 border-info h-full"
            style="height:100%;"
          >
            <label class="label">
              <span class="label-text text-info font-bold">Content Files</span>
            </label>
            <div
              id="file-list-container"
              class="flex flex-col gap-1 h-full overflow-y-auto"
            >
              <button
                id="new-file-btn"
                class="btn btn-success btn-sm w-full text-left justify-start"
                type="button"
              >
                (New File)
              </button>
              <div id="file-list" class="flex flex-col gap-1">
                <!-- Files will be loaded here -->
              </div>
            </div>
          </div>
        </div>

        <!-- TMDB Debug Column -->
        <div class="flex flex-col w-full max-w-xs" style="max-width: 22rem;">
          <div
            id="tmdb-debug-card"
            class="bg-base-200 p-8 rounded-lg shadow-lg flex flex-col gap-4 border-2 border-error hidden h-full"
            style="height:100%;"
          >
            <label class="label">
              <span class="label-text text-error">TMDB API Result</span>
            </label>
            <textarea
              id="tmdb-debug-json"
              class="textarea textarea-bordered w-full h-full flex-grow font-mono text-xs resize-none"
              readonly></textarea>
          </div>
        </div>
        <form
          id="dev-form"
          class="w-full max-w-lg bg-base-200 p-8 rounded-lg shadow-lg flex flex-col gap-4 h-full"
          style="height:100%"
        >
          <!-- General Info -->
          <div class="form-control">
            <label class="label">
              <span class="label-text">ID (auto-generated)</span>
            </label>
            <input
              id="id"
              name="id"
              type="text"
              class="input input-bordered"
              readonly
            />
          </div>
          <div class="flex gap-4">
            <div class="form-control flex-1">
              <label class="label">
                <span class="label-text">Title</span>
              </label>
              <input
                id="title"
                name="title"
                type="text"
                placeholder="Title"
                class="input input-bordered"
                required
              />
            </div>
            <div class="form-control flex-1">
              <label class="label">
                <span class="label-text">TMDB ID</span>
              </label>
              <div class="flex gap-2">
                <input
                  id="tmdbid"
                  name="tmdbid"
                  type="text"
                  placeholder="TMDB ID"
                  class="input input-bordered flex-1"
                />
                <button
                  id="fetch-tmdb"
                  type="button"
                  class="btn btn-outline btn-error">Fetch</button
                >
              </div>
            </div>
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Original Title</span>
            </label>
            <input
              id="orgtitle"
              name="orgtitle"
              type="text"
              placeholder="Original Title"
              class="input input-bordered"
            />
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Country (geo)</span>
            </label>
            <select name="geo" class="select select-bordered" required>
              <option value="">Select country</option>
              <option value="gb">United Kingdom</option>
              <option value="de">Germany</option>
              <option value="fr">France</option>
              <option value="es">Spain</option>
              <option value="it">Italy</option>
              <option value="pt">Portugal</option>
              <option value="nl">Netherlands</option>
              <option value="se">Sweden</option>
              <option value="dk">Denmark</option>
              <option value="no">Norway</option>
              <option value="fi">Finland</option>
              <option value="is">Iceland</option>
              <option value="fo">Faroe Islands</option>
              <option value="pl">Poland</option>
              <option value="ru">Russia</option>
              <option value="cz">Czech Republic</option>
              <option value="hu">Hungary</option>
              <option value="ro">Romania</option>
              <option value="bg">Bulgaria</option>
              <option value="hr">Croatia</option>
              <option value="sk">Slovakia</option>
              <option value="si">Slovenia</option>
              <option value="ee">Estonia</option>
              <option value="lv">Latvia</option>
              <option value="lt">Lithuania</option>
              <option value="ua">Ukraine</option>
              <option value="by">Belarus</option>
              <option value="gr">Greece</option>
              <option value="mt">Malta</option>
              <option value="al">Albania</option>
              <option value="mk">North Macedonia</option>
              <option value="rs">Serbia</option>
              <option value="ba">Bosnia and Herzegovina</option>
              <option value="me">Montenegro</option>
              <option value="ie">Ireland</option>
              <option value="lu">Luxembourg</option>
              <option value="at">Austria</option>
              <option value="ch">Switzerland</option>
              <option value="be">Belgium</option>
              <option value="li">Liechtenstein</option>
              <option value="sm">San Marino</option>
              <option value="va">Vatican City</option>
              <option value="ad">Andorra</option>
              <option value="mc">Monaco</option>
            </select>
          </div>
          <!-- Channel object -->
          <div class="form-control border border-base-300 rounded-lg p-4 mb-2">
            <label class="label">
              <span class="label-text font-bold">Channel Info</span>
            </label>
            <input
              id="channel_name"
              name="channel_name"
              type="text"
              placeholder="Channel Name"
              class="input input-bordered mb-2"
            />
            <select
              id="channel_country"
              name="channel_country"
              class="select select-bordered mb-2"
            >
              <option value="">Select country</option>
              <option value="gb">United Kingdom</option>
              <option value="de">Germany</option>
              <option value="fr">France</option>
              <option value="es">Spain</option>
              <option value="it">Italy</option>
              <option value="pt">Portugal</option>
              <option value="nl">Netherlands</option>
              <option value="se">Sweden</option>
              <option value="dk">Denmark</option>
              <option value="no">Norway</option>
              <option value="fi">Finland</option>
              <option value="is">Iceland</option>
              <option value="fo">Faroe Islands</option>
              <option value="pl">Poland</option>
              <option value="ru">Russia</option>
              <option value="cz">Czech Republic</option>
              <option value="hu">Hungary</option>
              <option value="ro">Romania</option>
              <option value="bg">Bulgaria</option>
              <option value="hr">Croatia</option>
              <option value="sk">Slovakia</option>
              <option value="si">Slovenia</option>
              <option value="ee">Estonia</option>
              <option value="lv">Latvia</option>
              <option value="lt">Lithuania</option>
              <option value="ua">Ukraine</option>
              <option value="by">Belarus</option>
              <option value="gr">Greece</option>
              <option value="mt">Malta</option>
              <option value="al">Albania</option>
              <option value="mk">North Macedonia</option>
              <option value="rs">Serbia</option>
              <option value="ba">Bosnia and Herzegovina</option>
              <option value="me">Montenegro</option>
              <option value="ie">Ireland</option>
              <option value="lu">Luxembourg</option>
              <option value="at">Austria</option>
              <option value="ch">Switzerland</option>
              <option value="be">Belgium</option>
              <option value="li">Liechtenstein</option>
              <option value="sm">San Marino</option>
              <option value="va">Vatican City</option>
              <option value="ad">Andorra</option>
              <option value="mc">Monaco</option>
            </select>
            <input
              id="channel_icon"
              name="channel_icon"
              type="text"
              placeholder="Channel Icon (optional)"
              class="input input-bordered mb-2"
            />
            <label class="label cursor-pointer">
              <span class="label-text">Channel Info (bool)</span>
              <input
                id="channel_info"
                name="channel_info"
                type="checkbox"
                class="checkbox ml-2"
              />
            </label>
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Type</span>
            </label>
            <select
              id="type"
              name="type"
              class="select select-bordered"
              required
            >
              <option value="movie">Movie</option>
              <option value="series">Series</option>
              <option value="y-movie">Youth Movie</option>
              <option value="y-series">Youth Series</option>
            </select>
          </div>
          <!-- Movie/Series Specific Fields -->
          <div id="duration-field" class="form-control">
            <label class="label">
              <span class="label-text">Duration (minutes)</span>
            </label>
            <input
              id="duration"
              name="duration"
              type="number"
              min="0"
              class="input input-bordered"
              required
            />
          </div>
          <div id="series-fields" class="flex gap-4" style="display:none">
            <div class="form-control flex-1">
              <label class="label">
                <span class="label-text">Seasons</span>
              </label>
              <input
                id="seasons"
                name="seasons"
                type="number"
                min="0"
                class="input input-bordered"
                value="0"
              />
            </div>
            <div class="form-control flex-1">
              <label class="label">
                <span class="label-text">Episodes</span>
              </label>
              <input
                id="episodes"
                name="episodes"
                type="number"
                min="0"
                class="input input-bordered"
                value="0"
              />
            </div>
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Online Until</span>
            </label>
            <input
              id="onlineuntil"
              name="onlineuntil"
              type="date"
              class="input input-bordered"
              required
            />
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Quality</span>
            </label>
            <input
              id="quality"
              name="quality"
              type="text"
              class="input input-bordered"
              required
            />
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Audio Language(s)</span>
            </label>
            <input
              id="audio_lang"
              name="audio_lang"
              type="text"
              placeholder="e.g. de,en"
              class="input input-bordered"
            />
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Subtitle Language(s)</span>
            </label>
            <input
              id="subtitle_lang"
              name="subtitle_lang"
              type="text"
              placeholder="e.g. de,en"
              class="input input-bordered"
            />
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Forced Subtitle Language(s)</span>
            </label>
            <input
              id="forced_subtitle_lang"
              name="forced_subtitle_lang"
              type="text"
              placeholder="e.g. de"
              class="input input-bordered"
            />
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Description (HTML allowed)</span>
            </label>
            <textarea
              id="description"
              name="description"
              class="textarea textarea-bordered"
              required></textarea>
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Backdrop URL</span>
            </label>
            <input
              id="backdrop"
              name="backdrop"
              type="text"
              placeholder="Backdrop image URL"
              class="input input-bordered"
            />
          </div>
          <div class="form-control">
            <label class="label">
              <span class="label-text">Poster URL</span>
            </label>
            <input
              id="poster"
              name="poster"
              type="text"
              placeholder="Poster image URL"
              class="input input-bordered"
            />
          </div>
          <!-- Movie/Series Source Fields -->
          <div id="movie-source-fields" class="form-control">
            <label class="label">
              <span class="label-text">Source (Movie)</span>
            </label>
            <input
              name="movie_src"
              type="text"
              placeholder="Source URL"
              class="input input-bordered mb-2"
            />
            <select name="movie_type" class="select select-bordered mb-2">
              <option value="">Select Type</option>
              <option value="mpd">mpd</option>
              <option value="m3u8">m3u8</option>
              <option value="mp4">mp4</option>
              <option value="webm">webm</option>
            </select>
            <input
              name="movie_title"
              type="text"
              placeholder="Source Title"
              class="input input-bordered mb-2"
            />
          </div>
          <div
            id="series-source-fields"
            class="form-control"
            style="display:none"
          >
            <label class="label">
              <span class="label-text">Add Episode to Playlist</span>
            </label>
            <div class="flex flex-wrap gap-2 mt-2">
              <select
                id="playlist_type"
                class="select select-bordered flex-1 min-w-[120px]"
              >
                <option value="regular">regular</option>
                <option value="ov">ov</option>
              </select>
              <input
                id="playlist_season"
                type="number"
                min="1"
                placeholder="Season"
                class="input input-bordered flex-1 min-w-[100px]"
              />
              <input
                id="playlist_episode"
                type="number"
                min="1"
                placeholder="Episode"
                class="input input-bordered flex-1 min-w-[100px]"
              />
              <input
                id="playlist_title"
                type="text"
                placeholder="Episode Title"
                class="input input-bordered flex-1 min-w-[140px]"
              />
              <input
                id="playlist_description"
                type="text"
                placeholder="Episode Description (optional)"
                class="input input-bordered flex-1 min-w-[180px]"
              />
              <input
                id="playlist_audiolang"
                type="text"
                placeholder="Audio Lang(s) (comma, ov: single)"
                class="input input-bordered flex-1 min-w-[160px]"
              />
            </div>
            <div class="flex flex-col gap-2 mt-2">
              <textarea
                id="playlist_src"
                placeholder="Source URL(s) (one per line)"
                class="textarea textarea-bordered w-full min-h-[60px]"
                style="resize:vertical"></textarea>
              <select
                id="playlist_srctype"
                class="select select-bordered w-full"
              >
                <option value="">Select Type</option>
                <option value="mpd">mpd</option>
                <option value="m3u8">m3u8</option>
                <option value="mp4">mp4</option>
                <option value="webm">webm</option>
              </select>
              <button
                id="add-episode"
                type="button"
                class="btn btn-secondary w-full">Add</button
              >
            </div>
            <div id="playlist-list" class="mt-2"></div>
          </div>
          <!-- Cast and Crew fields removed from form as requested -->
          <div class="form-control">
            <label class="label cursor-pointer">
              <span class="label-text">FSK Check</span>
              <input name="fskcheck" type="checkbox" class="checkbox ml-2" />
            </label>
          </div>
          <div class="form-control">
            <label class="label cursor-pointer">
              <span class="label-text">Dyna</span>
              <input name="dyna" type="checkbox" class="checkbox ml-2" />
            </label>
          </div>
          <!-- Hidden input for spoken_languages to ensure it is included in debug JSON -->
          <input type="hidden" id="spoken_languages" name="spoken_languages" />
          <div class="form-control mt-6">
            <button type="submit" class="btn btn-primary w-full">Submit</button>
          </div>
        </form>
        <div
          class="flex flex-col gap-4 w-full max-w-xs"
          style="max-width: 22rem;"
        >
          <div
            id="debug-card"
            class="bg-base-200 p-8 rounded-lg shadow-lg flex flex-col gap-4"
            style="height:auto;"
          >
            <label class="label flex justify-between items-center">
              <span class="label-text">Debug: Form JSON</span>
              <button
                id="save-json-btn"
                type="button"
                class="btn btn-xs btn-success"
                disabled
                title="Save JSON to content collection folder">Save</button
              >
            </label>
            <textarea
              id="debug-json"
              class="textarea textarea-bordered w-full h-full font-mono text-xs resize-none"
              readonly></textarea>
          </div>
        </div>
        <!-- 4th column: Episode JSON debug -->
        <div class="flex flex-col w-full max-w-lg" style="max-width: 32rem;">
          <div
            id="episode-debug-card"
            class="bg-base-200 p-8 rounded-lg shadow-lg flex flex-col gap-4 h-full"
            style="height:100%;"
          >
            <label class="label flex flex-row items-center gap-2">
              <span class="label-text">Episode JSON (API)</span>
              <span
                id="season-episode-count"
                class="text-xs text-base-content/70"></span>
            </label>
            <div
              id="episode-debug-list"
              class="overflow-y-auto flex-1"
              style="height:100%;"
            >
            </div>
          </div>
        </div>
      </div>
      <script>
        // TMDB Fetch logic
        const fetchTmdbBtn = document.getElementById("fetch-tmdb");
        const tmdbDebugCard = document.getElementById("tmdb-debug-card");
        const tmdbDebugJson = document.getElementById("tmdb-debug-json");
        const tmdbIdInput = document.getElementById("tmdbid");
        const typeSelectInput = document.getElementById("type");

        // Enable/disable fetch button based on TMDB ID
        function updateFetchBtnState() {
          if (fetchTmdbBtn && tmdbIdInput) {
            if (fetchTmdbBtn instanceof HTMLButtonElement) {
              fetchTmdbBtn.disabled = !(
                tmdbIdInput instanceof HTMLInputElement &&
                tmdbIdInput.value.trim().length > 0
              );
            }
          }
        }
        if (tmdbIdInput) {
          tmdbIdInput.addEventListener("input", updateFetchBtnState);
          updateFetchBtnState();
        }

        if (fetchTmdbBtn && tmdbDebugCard && tmdbDebugJson) {
          fetchTmdbBtn.addEventListener("click", async function () {
            tmdbDebugCard.classList.remove("hidden");
            (tmdbDebugJson as HTMLTextAreaElement).value = "Loading...";
            try {
              // Determine correct API URL based on type
              let tmdbid = "";
              if (tmdbIdInput && tmdbIdInput instanceof HTMLInputElement) {
                tmdbid = tmdbIdInput.value.trim();
              }
              let typeVal = "movie";
              if (
                typeSelectInput &&
                typeSelectInput instanceof HTMLSelectElement
              ) {
                typeVal = typeSelectInput.value;
              }
              let url = "";
              if (typeVal === "series" || typeVal === "y-series") {
                url = `https://api3.mediathek.community/tv/${tmdbid}`;
              } else {
                url = `https://api3.mediathek.community/movie/${tmdbid}`;
              }
              if (!tmdbid) throw new Error("Please enter a TMDB ID.");
              const resp = await fetch(url);
              if (!resp.ok) throw new Error("HTTP " + resp.status);
              const data = await resp.json();
              (tmdbDebugJson as HTMLTextAreaElement).value = JSON.stringify(
                data,
                null,
                2
              );
              // --- Map TMDB fields to form fields (except id) ---
              // Helper: set value if element exists and is input/select/textarea
              function setField(id: string, value: any) {
                const el = document.getElementById(id);
                if (!el) return;
                if (
                  el instanceof HTMLInputElement ||
                  el instanceof HTMLSelectElement ||
                  el instanceof HTMLTextAreaElement
                ) {
                  if (
                    el instanceof HTMLInputElement &&
                    el.type === "checkbox"
                  ) {
                    el.checked = !!value;
                  } else {
                    el.value = value ?? "";
                  }
                }
              }

              setField("title", data.title || "");
              setField("tmdbid", data.id || "");
              // Always set orgtitle field by id, even if original_title is empty
              const orgtitleInput = document.getElementById("orgtitle");
              let orgtitleValue = "";
              if (
                typeof data.original_title === "string" &&
                data.original_title.length > 0
              ) {
                orgtitleValue = data.original_title;
              } else if (
                typeof data.orgtitle === "string" &&
                data.orgtitle.length > 0
              ) {
                orgtitleValue = data.orgtitle;
              } else if (
                typeof data.title === "string" &&
                data.title.length > 0
              ) {
                orgtitleValue = data.title;
              }
              if (orgtitleInput && "value" in orgtitleInput)
                orgtitleInput.value = orgtitleValue;
              // Country/geo and Channel fields are user input only; do not map from TMDB
              // Description
              setField("description", data.description || data.overview || "");
              // Backdrop and Poster - different fields based on type
              if (typeVal === "series" || typeVal === "y-series") {
                // For series: use backdrop_path and poster_path
                setField("backdrop", data.backdrop_path || "");
                setField("poster", data.poster_path || "");
              } else {
                // For movies: use backdrop and poster
                setField("backdrop", data.backdrop || "");
                setField("poster", data.poster || "");
              }
              // Duration
              setField("duration", data.runtime || "");
              // Seasons/Episodes
              setField("seasons", data.seasons || "");
              setField("episodes", data.episodes || "");
              // Quality (not in API, leave blank)
              setField("quality", "");
              // Audio languages
              if (
                Array.isArray(data.spoken_languages) &&
                data.spoken_languages.length > 0
              ) {
                // Set audio_lang as before
                setField(
                  "audio_lang",
                  data.spoken_languages.map((l: any) => l.iso_639_1).join(",")
                );
                // Set spoken_languages (optional, schema-compliant)
                setField(
                  "spoken_languages",
                  data.spoken_languages.map((l: any) => l.iso_639_1).join(",")
                );
                // Also update the hidden input for spoken_languages
                const spokenInput = document.getElementById("spoken_languages");
                if (spokenInput && "value" in spokenInput)
                  spokenInput.value = data.spoken_languages
                    .map((l: any) => l.iso_639_1)
                    .join(",");
              } else if (data.original_language) {
                setField("audio_lang", data.original_language);
                setField("spoken_languages", data.original_language);
                // Also update the hidden input for spoken_languages
                const spokenInput = document.getElementById("spoken_languages");
                if (spokenInput && "value" in spokenInput)
                  spokenInput.value = data.original_language;
              }
              // Subtitle/forced subtitle (not in API, leave blank)
              setField("subtitle_lang", "");
              setField("forced_subtitle_lang", "");
              // Poster/backdrop (not in form, but could be used elsewhere)
              // Cast
              if (Array.isArray(data.credits?.cast)) {
                window.castArr = data.credits.cast.map((c: any) => ({
                  id: String(c.id),
                  name: c.name,
                }));
              }
              // Crew
              if (Array.isArray(data.credits?.crew)) {
                window.crewArr = data.credits.crew.map((c: any) => ({
                  id: String(c.id),
                  name: c.name,
                }));
              }
              // Update debug JSON
              if (typeof updateDebugJson === "function") updateDebugJson();

              // --- EPISODE JSON FETCH LOGIC FOR SERIES ---
              // Only for type series/y-series
              const typeSelect = document.getElementById("type");
              const episodeDebugList =
                document.getElementById("episode-debug-list");
              const seasonEpisodeCountLabel = document.getElementById(
                "season-episode-count"
              );
              if (typeSelect && episodeDebugList) {
                const typeVal = (typeSelect as HTMLSelectElement).value;
                if (typeVal === "series" || typeVal === "y-series") {
                  // Get TMDB ID
                  const tmdbid = data.id || "";
                  // Use number_of_seasons for dropdown and label
                  let numberOfSeasons = 1;
                  if (
                    typeof data.number_of_seasons === "number" &&
                    data.number_of_seasons > 0
                  ) {
                    numberOfSeasons = data.number_of_seasons;
                  }
                  // Show season count in label
                  if (seasonEpisodeCountLabel) {
                    seasonEpisodeCountLabel.textContent = `(Seasons: ${numberOfSeasons})`;
                  }
                  episodeDebugList.innerHTML = "";
                  // --- Dropdown for seasons ---
                  const seasonSelectLabel = document.createElement("label");
                  seasonSelectLabel.className = "block mb-2 font-bold";
                  seasonSelectLabel.textContent = "Select Season:";
                  episodeDebugList.appendChild(seasonSelectLabel);
                  const seasonSelect = document.createElement("select");
                  seasonSelect.className = "select select-bordered mb-4";
                  seasonSelect.innerHTML =
                    '<option value="">-- Select --</option>';
                  for (let i = 1; i <= numberOfSeasons; i++) {
                    const option = document.createElement("option");
                    option.value = String(i);
                    option.textContent = `Season ${i}`;
                    seasonSelect.appendChild(option);
                  }
                  episodeDebugList.appendChild(seasonSelect);
                  // Container for episodes
                  const episodesContainer = document.createElement("div");
                  episodeDebugList.appendChild(episodesContainer);
                  seasonSelect.addEventListener("change", async function () {
                    episodesContainer.innerHTML = "";
                    const season = seasonSelect.value;
                    if (!season) return;
                    // Fetch season data from TMDB API (German)
                    const tmdbSeasonUrl = `https://api3.mediathek.community/episode/${tmdbid}/${season}?language=de-DE`;
                    let seasonData = null;
                    try {
                      const resp = await fetch(tmdbSeasonUrl, {
                        headers: {
                          // You must set your TMDB API key here if required, e.g. 'Authorization': 'Bearer ...'
                        },
                      });
                      if (!resp.ok) throw new Error("HTTP " + resp.status);
                      seasonData = await resp.json();
                    } catch (e) {
                      episodesContainer.innerText = `Season ${season}: Fehler beim Laden der Staffel: ${e && (e as any).message ? (e as any).message : String(e)}`;
                      return;
                    }
                    // Accept both array and object-with-episodes
                    let episodesArr = [];
                    if (Array.isArray(seasonData)) {
                      episodesArr = seasonData;
                    } else if (
                      seasonData &&
                      Array.isArray(seasonData.episodes)
                    ) {
                      episodesArr = seasonData.episodes;
                    }
                    if (!episodesArr.length) {
                      episodesContainer.innerText = `Season ${season}: Keine Episodendaten.`;
                      return;
                    }
                    for (let i = 0; i < episodesArr.length; i++) {
                      const ep = episodesArr[i];
                      const episode = ep.episode_number;
                      const epDiv = document.createElement("div");
                      epDiv.className =
                        "mb-4 border border-base-300 rounded p-2 bg-base-100";
                      epDiv.style.display = "flex";
                      epDiv.style.flexDirection = "column";
                      epDiv.innerText = `S${season}E${episode}: Loading...`;
                      episodesContainer.appendChild(epDiv);
                      try {
                        // Clear loading text
                        epDiv.innerText = "";
                        // 1. Row: season/episode
                        const row1 = document.createElement("div");
                        row1.className =
                          "font-bold text-sm mb-1 flex items-center gap-2";
                        row1.innerText = `Season ${season}, Episode ${episode}`;
                        // Add copy button for season/episode number
                        const copySEBtn = document.createElement("button");
                        copySEBtn.type = "button";
                        copySEBtn.className =
                          "btn btn-xs btn-outline btn-accent ml-2";
                        copySEBtn.innerText = "Copy S/E";
                        copySEBtn.title = "Copy season/episode to form fields";
                        copySEBtn.addEventListener("click", () => {
                          // Set the season and episode fields in the form
                          const playlistSeasonInput =
                            document.getElementById("playlist_season");
                          const playlistEpisodeInput =
                            document.getElementById("playlist_episode");
                          if (
                            playlistSeasonInput &&
                            (playlistSeasonInput instanceof HTMLInputElement ||
                              playlistSeasonInput instanceof
                                HTMLTextAreaElement)
                          ) {
                            playlistSeasonInput.value = String(season);
                          }
                          if (
                            playlistEpisodeInput &&
                            (playlistEpisodeInput instanceof HTMLInputElement ||
                              playlistEpisodeInput instanceof
                                HTMLTextAreaElement)
                          ) {
                            playlistEpisodeInput.value = String(episode);
                          }
                        });
                        row1.appendChild(copySEBtn);
                        epDiv.appendChild(row1);
                        // 2. Row: title + copy button
                        const row2 = document.createElement("div");
                        row2.className = "flex items-center gap-2 mb-1";
                        const titleSpan = document.createElement("span");
                        titleSpan.innerText = ep.name || ep.title || "";
                        row2.appendChild(titleSpan);
                        const copyTitleBtn = document.createElement("button");
                        copyTitleBtn.type = "button";
                        copyTitleBtn.className =
                          "btn btn-xs btn-outline btn-primary";
                        copyTitleBtn.innerText = "Copy Title";
                        copyTitleBtn.addEventListener("click", () => {
                          const title = ep.name || ep.title || "";
                          navigator.clipboard.writeText(title);
                          // Also set the episode title field in the form
                          const playlistTitleInput =
                            document.getElementById("playlist_title");
                          if (
                            playlistTitleInput &&
                            (playlistTitleInput instanceof HTMLInputElement ||
                              playlistTitleInput instanceof HTMLTextAreaElement)
                          ) {
                            playlistTitleInput.value = title;
                          }
                        });
                        row2.appendChild(copyTitleBtn);
                        epDiv.appendChild(row2);
                        // 3. Row: description in big box + copy button
                        const row3 = document.createElement("div");
                        row3.className = "flex items-start gap-2";
                        const descBox = document.createElement("textarea");
                        descBox.className =
                          "textarea textarea-bordered w-full min-h-[60px] font-mono text-xs";
                        descBox.readOnly = true;
                        descBox.value = ep.overview || ep.description || "";
                        row3.appendChild(descBox);
                        const copyDescBtn = document.createElement("button");
                        copyDescBtn.type = "button";
                        copyDescBtn.className =
                          "btn btn-xs btn-outline btn-primary";
                        copyDescBtn.innerText = "Copy Description";
                        copyDescBtn.addEventListener("click", () => {
                          const desc = ep.overview || ep.description || "";
                          navigator.clipboard.writeText(desc);
                          // Also set the episode description field in the form
                          const playlistDescriptionInput =
                            document.getElementById("playlist_description");
                          if (
                            playlistDescriptionInput &&
                            (playlistDescriptionInput instanceof
                              HTMLInputElement ||
                              playlistDescriptionInput instanceof
                                HTMLTextAreaElement)
                          ) {
                            playlistDescriptionInput.value = desc;
                          }
                        });
                        row3.appendChild(copyDescBtn);
                        epDiv.appendChild(row3);
                      } catch (e) {
                        const errMsg =
                          e && (e as any).message
                            ? (e as any).message
                            : String(e);
                        epDiv.innerText = `S${season}E${episode}: Error: ${errMsg}`;
                      }
                    }
                  });
                } else {
                  episodeDebugList.innerHTML = "";
                  if (seasonEpisodeCountLabel)
                    seasonEpisodeCountLabel.textContent = "";
                }
              }
              // --- END EPISODE JSON FETCH LOGIC ---
            } catch (e) {
              const errMsg =
                e && (e as any).message ? (e as any).message : String(e);
              (tmdbDebugJson as HTMLTextAreaElement).value = "Error: " + errMsg;
              const episodeDebugList =
                document.getElementById("episode-debug-list");
              if (episodeDebugList) episodeDebugList.innerHTML = "";
            }
          });
        }
        // Map short type to MIME type
        function getMimeType(type: string): string {
          switch (type) {
            case "mpd":
              return "application/dash+xml";
            case "m3u8":
              return "application/x-mpegURL";
            case "mp4":
              return "video/mp4";
            case "webm":
              return "video/webm";
            default:
              return type || "";
          }
        }

        // Map MIME type back to short type for form loading
        function getShortType(mimeType: string): string {
          switch (mimeType) {
            case "application/dash+xml":
              return "mpd";
            case "application/x-mpegURL":
              return "m3u8";
            case "video/mp4":
              return "mp4";
            case "video/webm":
              return "webm";
            default:
              return mimeType || "";
          }
        }

        // Cache frequently used DOM elements
        const formCard = document.getElementById("dev-form");
        const debugCard = document.getElementById("debug-card");
        const episodeDebugCard = document.getElementById("episode-debug-card");
        const fileListCard = document.getElementById("file-list-card");
        
        // Sync debug, tmdb debug, episode debug, and file list card height to form height
        function syncDebugCardHeight() {
          if (!formCard) return;
          
          const formHeight = formCard.offsetHeight;
          
          if (debugCard) {
            debugCard.style.height = formHeight + "px";
          }
          if (tmdbDebugCard) {
            tmdbDebugCard.style.height = formHeight + "px";
          }
          if (episodeDebugCard) {
            episodeDebugCard.style.height = formHeight + "px";
          }
          if (fileListCard) {
            fileListCard.style.height = formHeight + "px";
          }
        }
        window.addEventListener("resize", syncDebugCardHeight);
        window.addEventListener("DOMContentLoaded", syncDebugCardHeight);
        setTimeout(syncDebugCardHeight, 100); // In case of late layout
        // Auto-generate ID from title and channel
        // Also update debug/tmdb card height on form input
        if (formCard) {
          formCard.addEventListener("input", syncDebugCardHeight);
          formCard.addEventListener("change", syncDebugCardHeight);
        }
        const titleInput = document.getElementById("title");
        const channelInput = document.getElementById("channel_name");
        const idInput = document.getElementById("id");
        function updateId() {
          if (!titleInput || !channelInput || !idInput) return;
          const title = (
            titleInput instanceof HTMLInputElement ? titleInput.value : ""
          )
            .trim()
            .toLowerCase()
            .replace(/\s+/g, "-");
          const channel = (
            channelInput instanceof HTMLInputElement ? channelInput.value : ""
          )
            .trim()
            .toLowerCase()
            .replace(/\s+/g, "-");
          if (idInput instanceof HTMLInputElement) {
            idInput.value = title && channel ? `${title}-${channel}` : "";
          }
        }
        if (titleInput) titleInput.addEventListener("input", updateId);
        if (channelInput) channelInput.addEventListener("input", updateId);

        // Show/hide fields based on type
        function updateTypeFields() {
          const typeSelect = document.getElementById("type");
          const seriesFields = document.getElementById("series-fields");
          const movieSourceFields = document.getElementById(
            "movie-source-fields"
          );
          const seriesSourceFields = document.getElementById(
            "series-source-fields"
          );
          const channelNameInput = document.getElementById("channel_name");
          const channelCountryInput =
            document.getElementById("channel_country");
          if (
            !typeSelect ||
            !seriesFields ||
            !movieSourceFields ||
            !seriesSourceFields
          )
            return;
          const val = (typeSelect as HTMLSelectElement).value;
          const isSeriesType = val === "series" || val === "y-series";

          if (isSeriesType) {
            seriesFields.style.display = "";
            seriesSourceFields.style.display = "";
            movieSourceFields.style.display = "none";
            // Make channel fields required for series
            if (channelNameInput)
              (channelNameInput as HTMLInputElement).required = true;
            if (channelCountryInput)
              (channelCountryInput as HTMLSelectElement).required = true;
          } else {
            seriesFields.style.display = "none";
            seriesSourceFields.style.display = "none";
            movieSourceFields.style.display = "";
            // Make channel fields optional for movies
            if (channelNameInput)
              (channelNameInput as HTMLInputElement).required = false;
            if (channelCountryInput)
              (channelCountryInput as HTMLSelectElement).required = false;
          }
        }
        document.addEventListener("DOMContentLoaded", function () {
          const typeSelect = document.getElementById("type");
          if (typeSelect) {
            typeSelect.addEventListener("change", updateTypeFields);
            updateTypeFields();
          }
        });

        // Add series source entries to a list
        const addSeriesSourceBtn = document.getElementById("add-series-source");
        const seriesSourcesList = document.getElementById(
          "series-sources-list"
        );
        const seriesSrcInput = document.getElementById("series_src");
        const seriesTypeInput = document.getElementById("series_type");
        const seriesTitleInput = document.getElementById("series_title");
        let seriesSources: any[] = [];
        // Playlist structure: { regular: { [season: string]: any[] }, ov: { [season: string]: any[] } }
        type Playlist = {
          regular: { [season: string]: any[] };
          ov: { [season: string]: any[] };
        };
        let playlist: Playlist = { regular: {}, ov: {} };
        const addEpisodeBtn = document.getElementById("add-episode");
        const playlistTypeInput = document.getElementById("playlist_type");
        const playlistSeasonInput = document.getElementById("playlist_season");
        const playlistEpisodeInput =
          document.getElementById("playlist_episode");
        const playlistTitleInput = document.getElementById("playlist_title");
        const playlistDescriptionInput = document.getElementById(
          "playlist_description"
        );
        const playlistAudiolangInput =
          document.getElementById("playlist_audiolang");
        const playlistSrcInput = document.getElementById("playlist_src");
        const playlistSrctypeInput =
          document.getElementById("playlist_srctype");
        const playlistList = document.getElementById("playlist-list");
        function renderPlaylistList() {
          if (!playlistList) {
            return;
          }
          
          playlistList.innerHTML = "";
          ["regular", "ov"].forEach((type) => {
            const typeObj = (window.playlist as any)[type] as {
              [season: string]: any[];
            };
            
            const box = document.createElement("div");
            box.className =
              "bg-base-200 rounded-lg p-4 mb-4 flex-1 min-w-[260px] max-w-[420px]";
            const header = document.createElement("div");
            header.className = "font-bold text-lg mb-2";
            header.textContent = type.toUpperCase();
            box.appendChild(header);
            let hasAny = false;
            Object.entries(typeObj).forEach(([season, episodes]) => {
              (episodes as any[]).forEach((ep: any, idx: number) => {
                hasAny = true;
                const row = document.createElement("div");
                row.className =
                  "flex items-center justify-between border-b border-base-300 py-1 gap-2";
                const left = document.createElement("span");
                left.textContent = `Season ${season}, Ep ${ep.episode}`;
                row.appendChild(left);
                const removeBtn = document.createElement("button");
                removeBtn.type = "button";
                removeBtn.className = "btn btn-xs btn-error btn-outline";
                removeBtn.innerText = "Remove";
                removeBtn.title = "Remove this episode from playlist";
                removeBtn.addEventListener("click", () => {
                  // Remove this episode from playlist object
                  (window.playlist as any)[type][season].splice(idx, 1);
                  // If season is empty after removal, delete the season key
                  if ((window.playlist as any)[type][season].length === 0) {
                    delete (window.playlist as any)[type][season];
                  }
                  renderPlaylistList();
                  if (typeof updateDebugJson === "function") updateDebugJson();
                });
                row.appendChild(removeBtn);
                box.appendChild(row);
              });
            });
            if (!hasAny) {
              const empty = document.createElement("div");
              empty.className = "text-base-content/50 italic";
              empty.textContent = "No entries.";
              box.appendChild(empty);
            }
            playlistList.appendChild(box);
          });
        }
        if (
          addEpisodeBtn &&
          playlistTypeInput &&
          playlistSeasonInput &&
          playlistEpisodeInput &&
          playlistTitleInput &&
          playlistDescriptionInput &&
          playlistAudiolangInput &&
          playlistSrcInput &&
          playlistSrctypeInput
        ) {
          addEpisodeBtn.addEventListener("click", function () {
            const type =
              playlistTypeInput instanceof HTMLSelectElement
                ? playlistTypeInput.value
                : "regular";
            const season =
              playlistSeasonInput instanceof HTMLInputElement
                ? playlistSeasonInput.value.trim()
                : "";
            const episode =
              playlistEpisodeInput instanceof HTMLInputElement
                ? playlistEpisodeInput.value.trim()
                : "";
            const title =
              playlistTitleInput instanceof HTMLInputElement
                ? playlistTitleInput.value.trim()
                : "";
            const description =
              playlistDescriptionInput instanceof HTMLInputElement
                ? playlistDescriptionInput.value.trim()
                : "";
            const audiolang =
              playlistAudiolangInput instanceof HTMLInputElement
                ? playlistAudiolangInput.value.trim()
                : "";
            const srcRaw =
              playlistSrcInput instanceof HTMLTextAreaElement
                ? playlistSrcInput.value
                : "";
            const srctype =
              playlistSrctypeInput instanceof HTMLSelectElement
                ? playlistSrctypeInput.value
                : playlistSrctypeInput instanceof HTMLInputElement
                  ? playlistSrctypeInput.value
                  : "";
            const srcList = srcRaw
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean);
            if (
              season &&
              episode &&
              title &&
              audiolang &&
              srcList.length > 0 &&
              srctype
            ) {
              // For ov: audiolang is string, for regular: array
              const audiolangVal =
                type === "ov"
                  ? audiolang
                  : audiolang
                      .split(",")
                      .map((s) => s.trim())
                      .filter(Boolean);
              const sourcesArr = srcList.map((src) => ({
                src,
                type: getMimeType(srctype),
              }));
              const epObj = {
                season: Number(season),
                episode: Number(episode),
                title,
                description: description || undefined,
                audiolang: audiolangVal,
                sources: sourcesArr,
              };
              if (!(window.playlist as any)[type][season])
                (window.playlist as any)[type][season] = [];
              (window.playlist as any)[type][season].push(epObj);
              renderPlaylistList();
              // Update debug JSON after playlist add
              if (typeof updateDebugJson === "function") updateDebugJson();
              // Clear inputs
              if (playlistSeasonInput instanceof HTMLInputElement)
                playlistSeasonInput.value = "";
              if (playlistEpisodeInput instanceof HTMLInputElement)
                playlistEpisodeInput.value = "";
              if (playlistTitleInput instanceof HTMLInputElement)
                playlistTitleInput.value = "";
              if (playlistDescriptionInput instanceof HTMLInputElement)
                playlistDescriptionInput.value = "";
              if (playlistAudiolangInput instanceof HTMLInputElement)
                playlistAudiolangInput.value = "";
              if (playlistSrcInput instanceof HTMLTextAreaElement)
                playlistSrcInput.value = "";
              if (playlistSrctypeInput instanceof HTMLSelectElement)
                playlistSrctypeInput.value = "";
            }
          });
        }
        // Debug: Show JSON object from form values (nested, schema-like)
        const debugJson = document.getElementById("debug-json");
        const form = document.getElementById("dev-form");
        // Cast and Crew display as readonly JSON
        let castArr: Array<{ id: number | string; name: string }> = [];
        let crewArr: Array<{ id: number | string; name: string }> = [];
        // Make arrays global for debug
        window.playlist = playlist;
        window.castArr = castArr;
        window.crewArr = crewArr;

        // Global variable to store loaded timestamp data
        let loadedTimestamps = {
          created: null,
          lastupdated: null,
        };

        function getFormJson() {
          // Main fields
          const tmdbInput = document.getElementById("tmdbid");
          const orgtitleInput = document.getElementById("orgtitle");
          const geoInput = form && "geo" in form ? form.geo : null;
          const fskInput = form && "fskcheck" in form ? form.fskcheck : null;
          const dynaInput = form && "dyna" in form ? form.dyna : null;
          const movieSrcInput =
            form && "movie_src" in form ? form.movie_src : null;
          const movieTypeInput =
            form && "movie_type" in form ? form.movie_type : null;
          const movieTitleInput =
            form && "movie_title" in form ? form.movie_title : null;
          // Channel object
          const channelNameInput = document.getElementById("channel_name");
          const channelCountryInput =
            document.getElementById("channel_country");
          const channelIconInput = document.getElementById("channel_icon");
          const channelInfoInput = document.getElementById("channel_info");
          // Info object (example: duration, seasons, episodes, onlineuntil, quality, description)
          const durationInput = document.getElementById("duration");
          const seasonsInput = document.getElementById("seasons");
          const episodesInput = document.getElementById("episodes");
          const onlineuntilInput = document.getElementById("onlineuntil");
          const qualityInput = document.getElementById("quality");
          const descriptionInput = document.getElementById("description");
          // Audio/subtitle fields
          const audioLangInput = document.getElementById("audio_lang");
          const subtitleLangInput = document.getElementById("subtitle_lang");
          const forcedSubtitleLangInput = document.getElementById(
            "forced_subtitle_lang"
          );
          // Get typeSelect locally for type safety
          const typeSelectEl = document.getElementById("type");
          const typeVal =
            typeSelectEl instanceof HTMLSelectElement ? typeSelectEl.value : "";
          // Type-safe window globals
          const castArr = Array.isArray(window.castArr) ? window.castArr : [];
          const crewArr = Array.isArray(window.crewArr) ? window.crewArr : [];
          const playlist =
            typeof window.playlist === "object" && window.playlist
              ? window.playlist
              : { regular: {}, ov: {} };

          // Generate timestamp info for debug display
          const now = new Date().toISOString();
          const id = idInput instanceof HTMLInputElement ? idInput.value : "";

          // Use loaded timestamps if available, otherwise show current time with explanation
          const createdTimestamp =
            loadedTimestamps.created ||
            `${now} (will be preserved if file exists)`;
          const lastUpdatedTimestamp =
            loadedTimestamps.lastupdated || `${now} (updated on each save)`;

          return {
            id: idInput instanceof HTMLInputElement ? idInput.value : "",
            title:
              titleInput instanceof HTMLInputElement ? titleInput.value : "",
            orgtitle:
              orgtitleInput instanceof HTMLInputElement
                ? orgtitleInput.value
                : "",
            geo: geoInput instanceof HTMLSelectElement ? geoInput.value : "",
            fskcheck:
              fskInput instanceof HTMLInputElement ? fskInput.checked : false,
            dyna:
              dynaInput instanceof HTMLInputElement ? dynaInput.checked : false,
            created: createdTimestamp,
            lastupdated: lastUpdatedTimestamp,
            info: {
              type: typeVal,
              duration:
                durationInput instanceof HTMLInputElement
                  ? Number(durationInput.value)
                  : 0,
              seasons:
                seasonsInput instanceof HTMLInputElement
                  ? Number(seasonsInput.value)
                  : 0,
              episodes:
                episodesInput instanceof HTMLInputElement
                  ? Number(episodesInput.value)
                  : 0,
              onlineuntil:
                onlineuntilInput instanceof HTMLInputElement &&
                onlineuntilInput.value
                  ? onlineuntilInput.value + "T23:59:59Z"
                  : "",
              quality:
                qualityInput instanceof HTMLInputElement
                  ? qualityInput.value
                  : "",
              description:
                descriptionInput instanceof HTMLTextAreaElement
                  ? descriptionInput.value
                  : "",
              backdrop:
                document.getElementById("backdrop") instanceof HTMLInputElement
                  ? (document.getElementById("backdrop") as HTMLInputElement)
                      .value
                  : "",
              poster:
                document.getElementById("poster") instanceof HTMLInputElement
                  ? (document.getElementById("poster") as HTMLInputElement)
                      .value
                  : "",
              channel: {
                name:
                  channelNameInput instanceof HTMLInputElement
                    ? channelNameInput.value
                    : "",
                country:
                  channelCountryInput instanceof HTMLSelectElement
                    ? channelCountryInput.value
                    : channelCountryInput instanceof HTMLInputElement
                      ? channelCountryInput.value
                      : "",
                icon:
                  channelIconInput instanceof HTMLInputElement
                    ? channelIconInput.value
                    : "",
                info:
                  channelInfoInput instanceof HTMLInputElement
                    ? channelInfoInput.checked
                    : false,
              },
              cast: castArr,
              crew: crewArr,
              // Optional spoken_languages field (schema-compliant: array of codes)
              spoken_languages:
                document.getElementById("spoken_languages") instanceof
                HTMLInputElement
                  ? (
                      document.getElementById(
                        "spoken_languages"
                      ) as HTMLInputElement
                    ).value
                      .split(",")
                      .map((s) => s.trim())
                      .filter(Boolean)
                  : undefined,
            },
            videosource:
              typeVal === "movie"
                ? {
                    src:
                      movieSrcInput instanceof HTMLInputElement
                        ? movieSrcInput.value
                        : "",
                    type: getMimeType(
                      movieTypeInput instanceof HTMLSelectElement
                        ? movieTypeInput.value
                        : movieTypeInput instanceof HTMLInputElement
                          ? movieTypeInput.value
                          : ""
                    ),
                    title:
                      movieTitleInput instanceof HTMLInputElement
                        ? movieTitleInput.value
                        : "",
                    poster: "",
                    audiolang: [],
                    sources: [],
                  }
                : undefined,
            playlist:
              typeVal === "series" || typeVal === "y-series"
                ? playlist
                : undefined,
          };
        }
        function updateDebugJson() {
          if (debugJson && debugJson instanceof HTMLTextAreaElement) {
            debugJson.value = JSON.stringify(getFormJson(), null, 2);
          }
          // Update save button state
          updateSaveButtonState();
        }

        // Save button functionality
        const saveJsonBtn = document.getElementById("save-json-btn");

        function updateSaveButtonState() {
          if (saveJsonBtn && idInput) {
            if (
              saveJsonBtn instanceof HTMLButtonElement &&
              idInput instanceof HTMLInputElement
            ) {
              saveJsonBtn.disabled = !idInput.value.trim();
            }
          }
        }

        async function saveJsonToFile() {
          if (!idInput || !(idInput instanceof HTMLInputElement)) return;
          const id = idInput.value.trim();
          if (!id) return;

          try {
            const jsonData = getFormJson();

            // Send to API endpoint to save on server
            const response = await fetch("/api/save-content", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                id: id,
                data: jsonData,
              }),
            });

            const result = await response.json();

            if (response.ok) {
              const action = result.isUpdate
                ? "Updated existing"
                : "Created new";
              alert(`Success: ${action} file ${id}.json in content/details/`);
            } else {
              throw new Error(result.error || "Failed to save file");
            }
          } catch (error) {
            console.error("Error saving JSON:", error);
            alert(
              `Error saving JSON file: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
        }

        if (saveJsonBtn) {
          saveJsonBtn.addEventListener("click", saveJsonToFile);
        }

        // Update save button state on ID field changes
        if (idInput) {
          idInput.addEventListener("input", updateSaveButtonState);
        }

        // Update JSON on input changes
        if (form) {
          form.addEventListener("input", updateDebugJson);
          form.addEventListener("change", updateDebugJson);
        }
        // Add explicit listeners for channel fields
        const channelNameInput = document.getElementById("channel_name");
        const channelCountryInput = document.getElementById("channel_country");
        const channelIconInput = document.getElementById("channel_icon");
        const channelInfoInput = document.getElementById("channel_info");
        if (channelNameInput) {
          channelNameInput.addEventListener("input", updateDebugJson);
        }
        if (channelCountryInput) {
          channelCountryInput.addEventListener("change", updateDebugJson);
        }
        if (channelIconInput) {
          channelIconInput.addEventListener("input", updateDebugJson);
        }
        if (channelInfoInput) {
          channelInfoInput.addEventListener("change", updateDebugJson);
        }
        // Add listeners for backdrop and poster fields
        const backdropInput = document.getElementById("backdrop");
        const posterInput = document.getElementById("poster");
        if (backdropInput) {
          backdropInput.addEventListener("input", updateDebugJson);
        }
        if (posterInput) {
          posterInput.addEventListener("input", updateDebugJson);
        }
        // Also update when series sources, cast, or crew change
        if (addSeriesSourceBtn) {
          addSeriesSourceBtn.addEventListener("click", updateDebugJson);
        }
        // Initial update
        updateDebugJson();

        // File List Functionality
        const fileListContainer = document.getElementById("file-list");
        const newFileBtn = document.getElementById("new-file-btn");

        // Function to clear the form
        function clearForm() {
          if (form && form instanceof HTMLFormElement) {
            form.reset();
          }

          // Clear additional fields not handled by form.reset()
          const fieldsToReset = [
            "id",
            "title",
            "orgtitle",
            "tmdbid",
            "description",
            "backdrop",
            "poster",
            "spoken_languages",
            "audio_lang",
            "subtitle_lang",
            "forced_subtitle_lang",
          ];

          fieldsToReset.forEach((fieldId) => {
            const field = document.getElementById(fieldId);
            if (field && "value" in field) {
              (field as HTMLInputElement).value = "";
            }
          });

          // Clear global arrays
          window.castArr = [];
          window.crewArr = [];
          window.playlist = { regular: {}, ov: {} };
          
          // Clear playlist display (will be rendered later if needed)
          if (playlistList) {
            playlistList.innerHTML = "";
          }

          // Clear loaded timestamps
          loadedTimestamps.created = null;
          loadedTimestamps.lastupdated = null;

          // Clear debug JSON
          updateDebugJson();

          // Hide TMDB debug card
          if (tmdbDebugCard) {
            tmdbDebugCard.classList.add("hidden");
          }

          // Clear episode debug
          const episodeDebugList =
            document.getElementById("episode-debug-list");
          if (episodeDebugList) {
            episodeDebugList.innerHTML = "";
          }
        }

        // Function to load file list
        async function loadFileList() {
          if (!fileListContainer) return;

          try {
            const response = await fetch("/api/list-content");
            const result = await response.json();

            if (response.ok && result.success) {
              fileListContainer.innerHTML = "";

              result.files.forEach((file: any) => {
                // Create container for file entry with load and delete buttons
                const fileEntry = document.createElement("div");
                fileEntry.className = "flex items-center gap-1 w-full";

                // Load button
                const fileBtn = document.createElement("button");
                fileBtn.className =
                  "btn btn-ghost btn-sm flex-1 text-left justify-start text-xs min-w-0";
                fileBtn.type = "button";
                fileBtn.innerHTML = `📁 ${file.id}`;
                fileBtn.title = `Last modified: ${new Date(file.lastModified).toLocaleString()}`;
                fileBtn.addEventListener("click", () => loadFile(file.id));

                fileEntry.appendChild(fileBtn);

                // Only add delete button if it's not "fallback"
                if (file.id !== "fallback") {
                  // Delete button
                  const deleteBtn = document.createElement("button");
                  deleteBtn.className =
                    "btn btn-ghost btn-sm btn-square text-error hover:bg-error hover:text-error-content text-xs";
                  deleteBtn.type = "button";
                  deleteBtn.innerHTML = "🗑️";
                  deleteBtn.title = `Delete ${file.id}`;
                  deleteBtn.addEventListener("click", (e) => {
                    e.stopPropagation();
                    deleteFile(file.id);
                  });

                  fileEntry.appendChild(deleteBtn);
                }

                fileListContainer.appendChild(fileEntry);
              });
            } else {
              fileListContainer.innerHTML =
                '<div class="text-error text-xs p-2">Failed to load files</div>';
            }
          } catch (error) {
            console.error("Error loading file list:", error);
            if (fileListContainer) {
              fileListContainer.innerHTML =
                '<div class="text-error text-xs p-2">Error loading files</div>';
            }
          }
        }

        // Function to load a specific file
        async function loadFile(fileId: string) {
          try {
            const response = await fetch(
              `/api/load-content?id=${encodeURIComponent(fileId)}`
            );
            const result = await response.json();

            if (response.ok && result.success) {
              let data = result.data;
              let needsResave = false;

              // Check if created field is empty and get file system creation date if needed
              if (!data.created) {
                try {
                  const statsResponse = await fetch(
                    `/api/get-file-stats?id=${encodeURIComponent(fileId)}`
                  );
                  const statsResult = await statsResponse.json();

                  if (statsResponse.ok && statsResult.success) {
                    data.created = statsResult.stats.created;
                    needsResave = true;
                  } else {
                    console.warn(
                      `Could not get file stats for ${fileId}: ${statsResult.error}`
                    );
                  }
                } catch (statsError) {
                  console.warn("Error getting file stats:", statsError);
                }
              }

              // If we added a created timestamp, save the file to persist it
              if (needsResave) {
                try {
                  const saveResponse = await fetch("/api/save-content", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                      id: fileId,
                      data: data,
                    }),
                  });

                  if (saveResponse.ok) {
                    // Refresh file list to reflect any changes
                    loadFileList();
                  } else {
                    console.warn(
                      "Failed to auto-save file with created timestamp"
                    );
                  }
                } catch (saveError) {
                  console.warn(
                    "Error auto-saving file with created timestamp:",
                    saveError
                  );
                }
              }

              // Clear form first
              clearForm();

              // Populate form fields with loaded data
              populateFormFromData(data);
            } else {
              alert(`Failed to load file: ${result.error || "Unknown error"}`);
            }
          } catch (error) {
            console.error("Error loading file:", error);
            alert(
              `Error loading file: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
        }

        // Function to populate form from loaded data
        function populateFormFromData(data: any) {
          // Store loaded timestamps globally
          loadedTimestamps.created = data.created || null;
          loadedTimestamps.lastupdated = data.lastupdated || null;

          // Helper function to set field value
          function setField(fieldId: string, value: any) {
            const field = document.getElementById(fieldId);
            if (!field) return;

            if (field instanceof HTMLInputElement) {
              if (field.type === "checkbox") {
                field.checked = !!value;
              } else if (field.type === "date" && value) {
                // Handle date fields - extract date part from ISO string
                field.value = value.split("T")[0];
              } else {
                field.value = value || "";
              }
            } else if (field instanceof HTMLSelectElement) {
              field.value = value || "";
            } else if (field instanceof HTMLTextAreaElement) {
              field.value = value || "";
            }
          }

          // Set basic fields
          setField("id", data.id);
          setField("title", data.title);
          setField("orgtitle", data.orgtitle);
          setField("geo", data.geo);
          setField("fskcheck", data.fskcheck);
          setField("dyna", data.dyna);

          if (data.info) {
            // Set info fields
            setField("type", data.info.type);
            setField("duration", data.info.duration);
            setField("seasons", data.info.seasons);
            setField("episodes", data.info.episodes);
            setField("onlineuntil", data.info.onlineuntil);
            setField("quality", data.info.quality);
            setField("description", data.info.description);
            setField("backdrop", data.info.backdrop);
            setField("poster", data.info.poster);

            // Set channel fields
            if (data.info.channel) {
              setField("channel_name", data.info.channel.name);
              setField("channel_country", data.info.channel.country);
              setField("channel_icon", data.info.channel.icon);
              setField("channel_info", data.info.channel.info);
            }

            // Set spoken languages
            if (
              data.info.spoken_languages &&
              Array.isArray(data.info.spoken_languages)
            ) {
              setField(
                "spoken_languages",
                data.info.spoken_languages.join(",")
              );
            }

            // Set cast and crew
            if (data.info.cast) {
              window.castArr = data.info.cast;
            }
            if (data.info.crew) {
              window.crewArr = data.info.crew;
            }
          }

          // Set movie source (if movie)
          if (data.videosource) {
            setField("movie_src", data.videosource.src);
            setField("movie_type", getShortType(data.videosource.type));
            setField("movie_title", data.videosource.title);
          }

          // Set playlist (if series)
          if (data.playlist && data.info && (data.info.type === 'series' || data.info.type === 'y-series')) {
            // Normalize playlist structure - ensure season keys match episode.season values
            const normalizedPlaylist: { regular: { [season: string]: any[] }, ov: { [season: string]: any[] } } = { regular: {}, ov: {} };
            
            Object.keys(data.playlist).forEach(playlistType => {
              if (data.playlist[playlistType] && typeof data.playlist[playlistType] === 'object') {
                (normalizedPlaylist as any)[playlistType] = {};
                
                Object.keys(data.playlist[playlistType]).forEach(seasonKey => {
                  const episodes = data.playlist[playlistType][seasonKey];
                  if (Array.isArray(episodes) && episodes.length > 0) {
                    // Use the actual season number from the first episode, or the seasonKey if it's numeric
                    const actualSeason = episodes[0].season || (isNaN(Number(seasonKey)) ? seasonKey : Number(seasonKey));
                    (normalizedPlaylist as any)[playlistType][String(actualSeason)] = episodes;
                  }
                });
              }
            });
            
            window.playlist = normalizedPlaylist;
            
            // Render the playlist to display loaded entries
            renderPlaylistList();
          }

          // Update field visibility based on type
          updateTypeFields();

          // Update debug JSON
          updateDebugJson();
        }

        // Function to delete a specific file
        async function deleteFile(fileId: string) {
          // Confirm deletion
          if (!confirm(`Are you sure you want to delete "${fileId}"? This action cannot be undone.`)) {
            return;
          }

          try {
            const response = await fetch(
              `/api/delete-content?id=${encodeURIComponent(fileId)}`,
              { method: 'DELETE' }
            );
            const result = await response.json();

            if (response.ok && result.success) {
              alert(`Successfully deleted file: ${fileId}`);
              
              // If the deleted file was currently loaded, clear the form
              const currentId = idInput instanceof HTMLInputElement ? idInput.value : "";
              if (currentId === fileId) {
                clearForm();
              }
              
              // Refresh file list
              loadFileList();
            } else {
              alert(`Failed to delete file: ${result.error || "Unknown error"}`);
            }
          } catch (error) {
            console.error("Error deleting file:", error);
            alert(
              `Error deleting file: ${error instanceof Error ? error.message : "Unknown error"}`
            );
          }
        }

        // New file button event listener
        if (newFileBtn) {
          newFileBtn.addEventListener("click", clearForm);
        }

        // Load file list on page load
        document.addEventListener("DOMContentLoaded", () => {
          loadFileList();
        });

        // Override save function to refresh file list
        const originalSaveJsonToFile = saveJsonToFile;
        async function enhancedSaveJsonToFile() {
          await originalSaveJsonToFile();
          // Refresh file list after successful save
          loadFileList();
        }

        if (saveJsonBtn) {
          saveJsonBtn.removeEventListener("click", saveJsonToFile);
          saveJsonBtn.addEventListener("click", enhancedSaveJsonToFile);
        }
      </script>
    </div>
  </div>
</Layout>
